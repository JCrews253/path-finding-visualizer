{"version":3,"sources":["algorithms/dijkstras/index.ts","algorithms/bestFirst/index.ts","components/header/header.tsx","algorithms/astar/index.ts","algorithms/depthFirst/index.ts","components/grid/grid.tsx","App.tsx","Reducers/startSearch/startSearchActions.ts","Reducers/algoSelect/algoSelectActions.ts","Reducers/gridTilt/gridTiltActions.ts","Reducers/searchSpeed/searchSpeedActions.ts","Reducers/boardChange/boardChangeAction.ts","Reducers/boardChange/boardChangeReducer.ts","store.ts","Reducers/algoSelect/algoSelectReducer.ts","Reducers/startSearch/startSearchReducer.ts","Reducers/gridTilt/gridTiltReducer.ts","Reducers/searchSpeed/searchSpeedReducer.ts","index.tsx"],"names":["animationQueue","size","Header","changeAlgo","startSearch","gridTilt","searchSpeed","boardCommand","tilt","useSelector","state","tiltState","className","htmlFor","onChange","e","document","getElementById","algoritm","options","selectedIndex","value","onAlgoChange","id","onClick","window","open","speed","speedValue","onSearchSpeed","AStarSearch","grid","width","start","finish","allowDiagonals","openNodes","closedNodes","nodeGrid","BuildNodeGrid","gWeight","hWeight","fWeight","parent","push","length","currentNode","FindSmallestCost","index","ListRemove","CalcNodeCosts","reverseQueue","pop","console","log","buildNodeGrid","map","_","idx","isWall","Infinity","EuclideanDistance","p","q","pCol","pRow","Math","floor","qCol","qRow","sqrt","pow","ManhattanDistance","abs","array","smallestIndex","ListContains","nodeList","i","gridIndex","splice","nodeIndex","UpdateWeightCost","parentIndex","tempNode","this","Dijkstra","sptSet","Array","fill","distance","FindMinNode","FindNodeDistances","heap","BestFirstSearch","visited","fcost","HeapInsert","HeapRemove","AddSurrondingNodes","Swap","index1","index2","temp","item","Parent","current","first","newHeap","slice","LeftChild","RightChild","HasLeftChild","HasRightChild","currentIndex","smallerIndex","Heapify","searchStack","DepthFirstSearch","Grid","onmousedown","type","mouseStatus","onmouseup","startMoveStatus","finishMoveStatus","onresize","HideHiddenWalls","nodeWidth","innerWidth","setNodeDimensions","wallPercent","ne","getElementsByClassName","newGrid","location","getBoundingClientRect","x","y","innerHeight","random","setGrid","CleanGrid","tempClassNames","j","classList","join","useState","rows","GetBlankGrid","columns","startNode","setStartNode","finishNode","setFinishNode","nodeDimensions","useRef","mouseIndex","hasSolution","algorithm","algoSelect","solving","boardChange","useEffect","animations","setTimeout","StartSearch","StartSearchInstant","clearBoard","clearPath","randomWalls","style","marginTop","transform","gridTemplateColumns","key","onMouseDown","HandleMouseDown","onMouseEnter","HandleMouseEnter","height","App","dispatch","useDispatch","onStartSearch","payload","algo","action","command","initState","rootReducer","combineReducers","store","createStore","ReactDOM","render"],"mappings":"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","file":"static/js/main.d30d9869.chunk.js","sourcesContent":["import { Animation } from '../astar/index'\r\n\r\nexport interface Node{\r\n    isWall: boolean,\r\n    distance: number,\r\n    parent: number, \r\n    index: number\r\n}\r\n\r\nvar animationQueue: Animation[]\r\n\r\nexport const Dijkstra = (grid:boolean[],width:number,start:number,finish:number):Animation[] =>{\r\n    animationQueue = []\r\n    const sptSet:boolean[] =new Array(grid.length).fill(false)\r\n    const nodeGrid:Node[] = new Array(grid.length)\r\n    for(let i=0; i< nodeGrid.length; i++){\r\n        nodeGrid[i] = {\r\n            isWall: grid[i] ? true : false,\r\n            distance: Infinity,\r\n            parent: -1,\r\n            index: i\r\n        }\r\n        sptSet[i] = nodeGrid[i].isWall\r\n    }\r\n    nodeGrid[start] = {\r\n        ...nodeGrid[start],\r\n        distance:0,\r\n        parent:start\r\n    }\r\n    while(!sptSet[finish]){\r\n        var currentNode = nodeGrid[FindMinNode(nodeGrid,sptSet,finish)]\r\n        animationQueue.push({index: currentNode.index, className: ' searched'})\r\n        FindNodeDistances(nodeGrid,sptSet,currentNode.index,width)\r\n        sptSet[currentNode.index] = true\r\n    }\r\n\r\n    var parent = nodeGrid[finish].parent  \r\n    if(parent !== -1){\r\n        var reverseQueue:Animation[] = [] \r\n        while(parent !== nodeGrid[parent].parent){\r\n            reverseQueue.push({index: parent, className: ' shortestPath'})\r\n            parent = nodeGrid[parent].parent\r\n        }\r\n        while(reverseQueue.length > 0) animationQueue.push(reverseQueue.pop() as Animation)\r\n    }\r\n    else \r\n    {\r\n        console.log('No Path Found')\r\n    }\r\n    return animationQueue\r\n}\r\n\r\nexport const FindMinNode = (nodeGrid:Node[], sptSet:boolean[],finish:number):number => {\r\n    let smallestIndex = finish\r\n    nodeGrid.map( (_,idx) => {\r\n        if(nodeGrid[idx].distance < nodeGrid[smallestIndex].distance && !sptSet[idx]){\r\n            smallestIndex = idx\r\n        }\r\n    })\r\n    return smallestIndex\r\n}\r\n\r\nexport const FindNodeDistances = (nodeGrid:Node[], sptSet:boolean[],nodeIndex:number, width:number) => {\r\n    const UpdateWeightCost = (index:number, parentIndex:number) => {\r\n        if(!nodeGrid[index].isWall && !sptSet[index]){\r\n            nodeGrid[index] = {\r\n                ...nodeGrid[index],\r\n                distance: nodeGrid[parentIndex].distance + 1,\r\n                parent: parentIndex\r\n            }\r\n            animationQueue.push({\r\n                index:index,\r\n                className: ' openList'\r\n            })\r\n        }\r\n    }\r\n\r\n    //Top\r\n    if(nodeIndex >= width){\r\n        UpdateWeightCost(nodeIndex-width,nodeIndex)\r\n    }\r\n    //Right\r\n    if(nodeIndex % width !== width-1){\r\n       UpdateWeightCost(nodeIndex+1,nodeIndex)\r\n    }\r\n    //Bottom\r\n    if(nodeIndex < nodeGrid.length - width){\r\n       UpdateWeightCost(nodeIndex+width,nodeIndex)\r\n    }\r\n    //Left\r\n    if(nodeIndex % width !== 0){\r\n       UpdateWeightCost(nodeIndex-1,nodeIndex)\r\n    }\r\n}","import { Animation } from '../astar/index'\r\nimport { inflate } from 'zlib'\r\n\r\nvar animationQueue: Animation[] = []\r\nvar heap:Node[] = []\r\nvar size: number\r\n\r\ninterface Node {\r\n    isWall: boolean,\r\n    visited: boolean,\r\n    fcost: number,\r\n    parent: number, \r\n    index: number\r\n}\r\n\r\nexport const BestFirstSearch = (grid:boolean[],width:number,start:number,finish:number):Animation[] => {\r\n    animationQueue = []\r\n    heap = []\r\n    size = 0\r\n    const nodeGrid:Node[] = new Array(grid.length)\r\n    for(let i=0;i<grid.length;i++){\r\n        nodeGrid[i] = {\r\n            isWall: grid[i],\r\n            visited: false,\r\n            fcost: (i === start) ? ManhattanDistance(i,finish,width): Infinity,\r\n            parent: (i === start)? start : -1,\r\n            index: i\r\n        }\r\n    }\r\n\r\n    HeapInsert(nodeGrid[start])\r\n\r\n    while(heap.length > 0 && heap.length < width * 20){\r\n        const currentNode = HeapRemove()\r\n        nodeGrid[currentNode.index] = { \r\n            ...currentNode,\r\n            visited: true,\r\n        }\r\n        animationQueue.push({\r\n            index:currentNode.index,\r\n            className: ' searched'\r\n        })\r\n        if(currentNode.index === finish) break\r\n        else AddSurrondingNodes(nodeGrid,currentNode.index,width,finish)\r\n    }\r\n\r\n    var parent = nodeGrid[finish].parent  \r\n    if(parent !== -1){\r\n        var reverseQueue:Animation[] = [] \r\n        while(parent !== nodeGrid[parent].parent){\r\n            reverseQueue.push({index: parent, className: ' shortestPath'})\r\n            parent = nodeGrid[parent].parent\r\n        }\r\n        while(reverseQueue.length > 0) animationQueue.push(reverseQueue.pop() as Animation)\r\n    }\r\n    else \r\n    {\r\n        console.log('No Path Found')\r\n    }\r\n    return animationQueue\r\n}\r\n\r\nexport const Heapify = (index:number) => {\r\n    const LeftChild = (index: number):number => Math.floor(2*index+1) \r\n    const RightChild = (index: number):number => Math.floor(2*index+2)\r\n    const HasLeftChild = (index: number):boolean => LeftChild(index) < size\r\n    const HasRightChild = (index: number):boolean => RightChild(index) < size\r\n\r\n    var currentIndex = index\r\n    while(HasLeftChild(currentIndex)){    \r\n        var smallerIndex = LeftChild(currentIndex)\r\n        if(HasRightChild(currentIndex) && \r\n        heap[RightChild(currentIndex)].fcost < heap[LeftChild(currentIndex)].fcost){\r\n            smallerIndex = RightChild(currentIndex)\r\n        }\r\n        if(heap[currentIndex].fcost < heap[smallerIndex].fcost) break\r\n        else Swap(currentIndex, smallerIndex)\r\n        currentIndex = smallerIndex\r\n    }\r\n}\r\n\r\nexport const Swap = (index1:number, index2:number) => {\r\n    const temp = heap[index1]\r\n    heap[index1] = heap[index2]\r\n    heap[index2] = temp\r\n}\r\n\r\nexport const HeapInsert = (item:Node) => {\r\n    const Parent = (index: number):number => Math.floor((index - 1) / 2)\r\n    const HasParent = (index: number):boolean => Parent(index) >= 0\r\n    heap[size] = item\r\n    size++\r\n    var current = size - 1 \r\n    while(HasParent(current) && (heap[current].fcost < heap[Parent(current)].fcost)){\r\n        Swap(current,Parent(current))\r\n        current = Parent(current)\r\n    }\r\n}\r\n\r\nexport const HeapRemove = ():Node => {\r\n    const first = heap[0]\r\n    heap[0] = heap[size - 1]\r\n    const newHeap = heap.slice(0,size-1)\r\n    heap = [...newHeap]\r\n    size--\r\n    Heapify(0)\r\n    return first\r\n}\r\n\r\nexport const ManhattanDistance = (p:number, q:number, width: number):number => {\r\n    const pRow = Math.floor(p/width)\r\n    var pCol\r\n    if(p >= width) pCol = p % width\r\n    else pCol = p\r\n    const qRow = Math.floor(q/width)\r\n    var qCol\r\n    if(q >= width) qCol = q % width\r\n    else qCol = q\r\n    return Math.floor((Math.abs(qRow - pRow) + Math.abs(qCol - pCol))*10)  \r\n}\r\n\r\nexport const AddSurrondingNodes = (nodeGrid:Node[],nodeIndex:number, width:number,finish:number) => {\r\n    const UpdateWeightCost = (index:number, parentIndex:number) => {\r\n        if(!nodeGrid[index].isWall && !nodeGrid[index].visited && nodeGrid[index].fcost === Infinity){\r\n            nodeGrid[index] = {\r\n                ...nodeGrid[index],\r\n                fcost: ManhattanDistance(index,finish,width),\r\n                parent: parentIndex\r\n            }\r\n            animationQueue.push({\r\n                index:index,\r\n                className: ' openList'\r\n            })\r\n            HeapInsert(nodeGrid[index])\r\n        }\r\n    }\r\n\r\n    //Top\r\n    if(nodeIndex >= width){\r\n        UpdateWeightCost(nodeIndex-width,nodeIndex)\r\n    }\r\n    //Right\r\n    if(nodeIndex % width !== width-1){\r\n       UpdateWeightCost(nodeIndex+1,nodeIndex)\r\n    }\r\n    //Bottom\r\n    if(nodeIndex < nodeGrid.length - width){\r\n       UpdateWeightCost(nodeIndex+width,nodeIndex)\r\n    }\r\n    //Left\r\n    if(nodeIndex % width !== 0){\r\n       UpdateWeightCost(nodeIndex-1,nodeIndex)\r\n    }\r\n}","import React from 'react'\r\nimport './header.css'\r\nimport { useSelector } from 'react-redux'\r\nimport { RootStore } from '../../store';\r\nimport {boardCommands} from '../../Reducers/boardChange/boardChangeAction'\r\n\r\ninterface IHeaderInputProps{\r\n    changeAlgo(algo:string): void,\r\n    startSearch(start:boolean): void,\r\n    gridTilt(tilt:boolean): void,\r\n    searchSpeed(speed:number): void,\r\n    boardCommand(state:boolean, action:boardCommands): void\r\n}\r\n\r\nconst Header: React.FC<IHeaderInputProps> = ({changeAlgo, startSearch, gridTilt,searchSpeed, boardCommand}) => {\r\n    const tilt = useSelector( (state:RootStore) => state.tiltState)\r\n\r\n    const onAlgoChange = () => {\r\n        const e = document.getElementById('algo-select') as HTMLSelectElement\r\n        const algoritm = e.options[e.selectedIndex].value\r\n        changeAlgo(algoritm)\r\n    }\r\n\r\n    const onStartSearch = () => {\r\n        startSearch(true)\r\n    }\r\n\r\n    const onGridTilt = () => {\r\n        gridTilt(tilt ? false : true)\r\n    }\r\n\r\n    const onSearchSpeed = () => {\r\n        const e = document.getElementById('speed-select') as HTMLSelectElement\r\n        const speed = e.options[e.selectedIndex].value\r\n        var speedValue = 10\r\n        if(speed === \"FAST\") speedValue = 10\r\n        if(speed === \"MEDIUM\") speedValue = 50\r\n        if(speed === \"SLOW\") speedValue = 100\r\n        searchSpeed(speedValue)\r\n    }\r\n    \r\n    const HandleGitHubClick = () => {\r\n        window.open(\"https://github.com/JCrews253/path-finding-visualizer\")\r\n    }\r\n\r\n    const solving = useSelector((state: RootStore) => state.startSearch)\r\n\r\n    return(\r\n        <div className='header'>\r\n            <h1 className='title'>Retro 80's Path Finding Visualization</h1>\r\n            <div className='label-element-container'>\r\n                <label className='algo-select-label' htmlFor='algo-select'>Choose an Algorithm:</label>\r\n                <select onChange={() => onAlgoChange()} id='algo-select'>\r\n                    <option value='astar'>A* Search</option>\r\n                    <option value='dijkstra'>Dijkstra's Algorithm</option>\r\n                    <option value='best-first'>Best First Search</option>\r\n                    <option value='depth-first'>Depth First Search</option>\r\n                    <option value='breadth-first'>Breadth First Search</option>\r\n                </select>\r\n            </div>\r\n            <div className='buttons-container'>\r\n                <button className='animated-button'>Home</button>\r\n                <button className='animated-button' onClick={()=> HandleGitHubClick()}>Github</button>\r\n                <hr/>\r\n                <button className='animated-button' onClick={() => onStartSearch()}>Start</button>\r\n                <button className='animated-button'onClick={() => boardCommand(true,\"CLEAR_PATH\")}>Clear Path</button>\r\n                <button className='animated-button'onClick={() => boardCommand(true,\"CLEAR_BOARD\")}>Clear Board</button>\r\n                <button className='animated-button'onClick={() => boardCommand(true,\"RANDOM_WALLS\")}>Random Walls</button>\r\n                <button className='animated-button' onClick={() => onGridTilt()}>Toggle Tilt</button>\r\n            </div>\r\n            <div className='label-element-container'>\r\n                <label className='speed-select-label' htmlFor='speed-select'>Choose Search Speed</label>\r\n                <select onChange={() => onSearchSpeed()} id='speed-select'>\r\n                    <option value='FAST'>Fast</option>\r\n                    <option value='MEDIUM'>Medium</option>\r\n                    <option value='SLOW'>Slow</option>\r\n                </select>\r\n            </div>\r\n        </div>\r\n    )\r\n}\r\n\r\nexport default Header","import '../../App.css'\r\n\r\nexport interface Node{\r\n    isWall: boolean,\r\n    gWeight: number,\r\n    hWeight: number,\r\n    fWeight: number,\r\n    parent: number, \r\n    index: number\r\n}\r\n\r\nexport interface Animation{\r\n    index: number,\r\n    className: string\r\n}\r\n\r\nvar animationQueue: Animation[] = []\r\n\r\nexport const AStarSearch = (grid: boolean[], width: number, start:number, finish: number, allowDiagonals: boolean):Animation[] => {\r\n    animationQueue = []\r\n    const openNodes: Node[] = []\r\n    const closedNodes:Node[] = []\r\n    const nodeGrid = [...BuildNodeGrid(grid)]\r\n\r\n    nodeGrid[start] = {\r\n        ...nodeGrid[start],\r\n        gWeight: 0,\r\n        hWeight: 0,\r\n        fWeight: 0,\r\n        parent: start\r\n    } \r\n    openNodes.push(nodeGrid[start])\r\n\r\n    while(openNodes.length > 0){\r\n        var currentNode = nodeGrid[FindSmallestCost(openNodes)]\r\n        if(currentNode.index !== start && currentNode.index !== finish) animationQueue.push({index: currentNode.index, className: ' searched'})\r\n        ListRemove(openNodes,currentNode.index)\r\n        closedNodes.push(currentNode)\r\n        if(currentNode.index === finish) break;\r\n        CalcNodeCosts(nodeGrid, currentNode.index, closedNodes, openNodes, start, finish, width, allowDiagonals)\r\n    }\r\n\r\n    var parent = nodeGrid[finish].parent\r\n    \r\n    if(parent !== -1){\r\n        var reverseQueue:Animation[] = [] \r\n        while(parent !== nodeGrid[parent].parent){\r\n            reverseQueue.push({index: parent, className: ' shortestPath'})\r\n            parent = nodeGrid[parent].parent\r\n        }\r\n        while(reverseQueue.length > 0) animationQueue.push(reverseQueue.pop() as Animation)\r\n    }\r\n    else \r\n    {\r\n        console.log('No Path Found')\r\n    }\r\n\r\n\r\n    return animationQueue\r\n}\r\n\r\nexport const BuildNodeGrid = (grid: boolean[]):Node[] => {\r\n    const buildNodeGrid:Node[] = []\r\n    grid.map( (_,idx) => {\r\n        buildNodeGrid[idx] = {\r\n            isWall: (grid[idx] === true) ? true : false,\r\n            gWeight: Infinity,\r\n            hWeight: Infinity,\r\n            fWeight: Infinity,\r\n            parent: -1,\r\n            index: idx,\r\n        }\r\n    })\r\n   return buildNodeGrid\r\n}\r\n\r\nexport const EuclideanDistance = (p:number, q:number, width: number):number => {\r\n    const pRow = Math.floor(p/width)\r\n    var pCol\r\n    if(p >= width) pCol = p % width\r\n    else pCol = p\r\n    const qRow = Math.floor(q/width)\r\n    var qCol\r\n    if(q >= width) qCol = q % width\r\n    else qCol = q\r\n    return Math.floor(Math.sqrt(Math.pow(qRow - pRow,2) + Math.pow(qCol - pCol,2))*10)  \r\n}\r\n\r\nexport const ManhattanDistance = (p:number, q:number, width: number):number => {\r\n    const pRow = Math.floor(p/width)\r\n    var pCol\r\n    if(p >= width) pCol = p % width\r\n    else pCol = p\r\n    const qRow = Math.floor(q/width)\r\n    var qCol\r\n    if(q >= width) qCol = q % width\r\n    else qCol = q\r\n    return Math.floor((Math.abs(qRow - pRow) + Math.abs(qCol - pCol))*10)  \r\n}\r\n\r\nexport const FindSmallestCost = (array:Node[]):number => {\r\n    let smallestIndex = 0\r\n    array.map( (_,idx) => {\r\n        if(array[idx].fWeight < array[smallestIndex].fWeight){\r\n            smallestIndex = idx\r\n        }\r\n        else if (array[idx].fWeight === array[smallestIndex].fWeight && array[idx].hWeight < array[smallestIndex].hWeight){\r\n            smallestIndex = idx\r\n        }\r\n    })\r\n    return array[smallestIndex].index\r\n}\r\n\r\nexport const ListContains = (nodeList: Node[], index:number):boolean => {\r\n    if(nodeList.length === 0 ) return false\r\n    for(let i = 0; i < nodeList.length; i++ ){\r\n        if(nodeList[i].index === index) return true\r\n    }\r\n    return false\r\n}\r\n\r\nexport const ListRemove = (nodeList: Node[], gridIndex:number) => {\r\n    for(let i = 0; i < nodeList.length; i++){\r\n        if(nodeList[i].index === gridIndex){\r\n            nodeList.splice(i,1)\r\n            break\r\n        }\r\n    }\r\n}\r\n\r\nexport const CalcNodeCosts = (nodeGrid:Node[], nodeIndex:number, closedNodes:Node[],openNodes:Node[],start:number,finish:number, width:number, allowDiagonals:boolean) => {\r\n    const UpdateWeightCost = (index:number,parentIndex:number) => {\r\n        if(!nodeGrid[index].isWall && !ListContains(closedNodes,index)){\r\n            if(index !== finish){\r\n                animationQueue.push({\r\n                    index:index,\r\n                    className: ' openList'\r\n                })\r\n            }\r\n            const tempNode:Node = { ...nodeGrid[index],\r\n                gWeight: nodeGrid[parentIndex].gWeight + (allowDiagonals ? EuclideanDistance(index,parentIndex,width) : ManhattanDistance(index,parentIndex,width)),\r\n                hWeight: allowDiagonals ? EuclideanDistance(index,finish,width) : ManhattanDistance(index, finish, width),\r\n                get fWeight (){\r\n                    return this.gWeight + this.hWeight\r\n                },\r\n                parent: parentIndex\r\n            }\r\n            if(tempNode.fWeight < nodeGrid[index].fWeight || !ListContains(openNodes,index)){\r\n                nodeGrid[index] = tempNode\r\n                openNodes.push(nodeGrid[index])\r\n            }\r\n            else if( tempNode.fWeight === nodeGrid[index].fWeight && tempNode.hWeight < nodeGrid[index].hWeight){\r\n                nodeGrid[index] = tempNode\r\n                openNodes.push(nodeGrid[index])\r\n            }\r\n        }\r\n    }\r\n\r\n    //Top\r\n    if(nodeIndex >= width){\r\n        UpdateWeightCost(nodeIndex-width,nodeIndex)\r\n    }\r\n    //Top-Right\r\n    if(nodeIndex >= width && nodeIndex % width !== width-1 && allowDiagonals){\r\n       UpdateWeightCost(nodeIndex-width+1,nodeIndex)\r\n    }\r\n    //Right\r\n    if(nodeIndex % width !== width-1){\r\n       UpdateWeightCost(nodeIndex+1,nodeIndex)\r\n    }\r\n    //Bottom-Right\r\n    if(nodeIndex % width !== width-1 && nodeIndex < nodeGrid.length - width && allowDiagonals){\r\n       UpdateWeightCost(nodeIndex+width+1,nodeIndex)\r\n    }\r\n    //Bottom\r\n    if(nodeIndex < nodeGrid.length - width){\r\n       UpdateWeightCost(nodeIndex+width,nodeIndex)\r\n    }\r\n    //Bottom-Left\r\n    if(nodeIndex < nodeGrid.length - width && nodeIndex % width !== 0 && allowDiagonals){\r\n       UpdateWeightCost(nodeIndex+width-1,nodeIndex)\r\n    }\r\n    //Left\r\n    if(nodeIndex % width !== 0){\r\n       UpdateWeightCost(nodeIndex-1,nodeIndex)\r\n    }\r\n    //Top-Left\r\n    if(nodeIndex % width !== 0 && nodeIndex >= width && allowDiagonals){\r\n       UpdateWeightCost(nodeIndex-width-1,nodeIndex)\r\n    }\r\n}","import { Animation } from '../astar/index'\r\n\r\ninterface Node{\r\n    isWall:boolean,\r\n    visited:boolean,\r\n    parent:number,\r\n    index:number\r\n}\r\n\r\nvar animationQueue: Animation[] = []\r\nvar searchStack: Node[] = []\r\n\r\nexport const DepthFirstSearch = (grid:boolean[],width:number,start:number,finish:number):Animation[] => {\r\n    animationQueue = []\r\n    searchStack = []\r\n    const nodeGrid: Node[] = []\r\n    for(let i = 0;i<grid.length;i++){\r\n        nodeGrid[i] = {\r\n            isWall: grid[i],\r\n            visited: false,\r\n            parent: (i === start) ? start : -1,\r\n            index: i\r\n        }\r\n    }\r\n\r\n    searchStack.push(nodeGrid[start])\r\n\r\n    while(searchStack.length > 0){\r\n        const currentNode = searchStack.pop() as Node\r\n        nodeGrid[currentNode.index] = {\r\n            ...currentNode,\r\n            visited: true\r\n        }\r\n        animationQueue.push({\r\n            index:currentNode.index,\r\n            className: ' searched'\r\n        })\r\n        if(currentNode.index === finish) break\r\n        else AddSurrondingNodes(nodeGrid,currentNode.index,width)\r\n    }\r\n    \r\n    var parent = nodeGrid[finish].parent  \r\n    if(parent !== -1){\r\n        var reverseQueue:Animation[] = [] \r\n        while(parent !== nodeGrid[parent].parent){\r\n            reverseQueue.push({index: parent, className: ' shortestPath'})\r\n            parent = nodeGrid[parent].parent\r\n        }\r\n        while(reverseQueue.length > 0) animationQueue.push(reverseQueue.pop() as Animation)\r\n    }\r\n    else \r\n    {\r\n        console.log('No Path Found')\r\n    }\r\n    return animationQueue\r\n}\r\n\r\nexport const AddSurrondingNodes = (nodeGrid:Node[],nodeIndex:number, width:number) => {\r\n    const UpdateWeightCost = (index:number, parentIndex:number) => {\r\n        if(!nodeGrid[index].isWall && !nodeGrid[index].visited){\r\n            nodeGrid[index] = {\r\n                ...nodeGrid[index],\r\n                parent: parentIndex\r\n            }\r\n            animationQueue.push({\r\n                index:index,\r\n                className: ' openList'\r\n            })\r\n            searchStack.push(nodeGrid[index])\r\n        }\r\n    }\r\n\r\n    //Top\r\n    if(nodeIndex >= width){\r\n        UpdateWeightCost(nodeIndex-width,nodeIndex)\r\n    }\r\n    //Right\r\n    if(nodeIndex % width !== width-1){\r\n       UpdateWeightCost(nodeIndex+1,nodeIndex)\r\n    }\r\n    //Bottom\r\n    if(nodeIndex < nodeGrid.length - width){\r\n       UpdateWeightCost(nodeIndex+width,nodeIndex)\r\n    }\r\n    //Left\r\n    if(nodeIndex % width !== 0){\r\n       UpdateWeightCost(nodeIndex-1,nodeIndex)\r\n    }\r\n}","import React, { useState, useRef, useEffect} from 'react';\r\nimport { AStarSearch, Animation } from '../../algorithms/astar'\r\nimport './grid.css'\r\nimport { useSelector } from 'react-redux';\r\nimport { RootStore } from '../../store';\r\nimport { truncate } from 'fs';\r\nimport { searchSpeed } from '../../Reducers/searchSpeed/searchSpeedActions';\r\nimport { boardCommand } from '../../Reducers/boardChange/boardChangeAction';\r\nimport { Dijkstra } from '../../algorithms/dijkstras';\r\nimport { BestFirstSearch } from '../../algorithms/bestFirst';\r\nimport { DepthFirstSearch } from '../../algorithms/depthFirst';\r\n\r\ninterface IGridInputProps{\r\n  startSearch(start:boolean):void,\r\n}\r\n\r\nconst rows = 18\r\nconst columns = 63\r\n\r\nconst Grid:React.FC<IGridInputProps> = ({startSearch}) => {\r\n  window.onmousedown = (e:MouseEvent) => {\r\n    if(e.type === 'mousedown') mouseStatus.current = true\r\n  }\r\n  window.onmouseup = (e:MouseEvent) => {\r\n    if(e.type === 'mouseup') {\r\n      mouseStatus.current = false\r\n      startMoveStatus.current = false\r\n      finishMoveStatus.current = false\r\n    }\r\n  }\r\n  window.onresize = () => {\r\n    if(tiltState){\r\n      HideHiddenWalls(20)\r\n    }\r\n    else {\r\n      const nodeWidth = (window.innerWidth - 200) / columns\r\n      setNodeDimensions(nodeWidth) \r\n    }\r\n  }\r\n  const HideHiddenWalls = (wallPercent:number) => {\r\n    const ne = document.getElementsByClassName('node') as HTMLCollectionOf<HTMLElement>\r\n      const newGrid = [...grid]\r\n      for(let i = 0; i < ne.length; i++){\r\n        const location = ne[i].getBoundingClientRect()\r\n        if(location.x + (location.width / 2) < 0 || location.x > window.innerWidth - 50 || location.y > window.innerHeight){\r\n          newGrid[i] = true\r\n        }\r\n        else{\r\n          newGrid[i] = (Math.random() >= (1 - (wallPercent/100)))\r\n        }\r\n      }\r\n      setGrid(newGrid)\r\n  }\r\n  const HandleMouseDown = (index:number) => {\r\n    if(!solving){\r\n      if(index === startNode) startMoveStatus.current = true\r\n      else if(index === finishNode) finishMoveStatus.current = true\r\n      else{\r\n        mouseIndex.current = index\r\n        const newGrid = [...grid]\r\n        newGrid[index] = grid[index] ? false : true\r\n        setGrid(newGrid)\r\n      }\r\n    }\r\n  }\r\n  const HandleMouseEnter = (index:number) => {\r\n    if(!solving){\r\n      if(startMoveStatus.current){\r\n        setStartNode(index)\r\n      }\r\n      else if(finishMoveStatus.current){\r\n        setFinishNode(index)\r\n      }\r\n      else if(mouseStatus.current && index !== mouseIndex.current){\r\n        mouseIndex.current = index\r\n        const newGrid = [...grid]\r\n        newGrid[index] = grid[index] ? false : true\r\n        setGrid(newGrid)\r\n      }\r\n    }\r\n  }\r\n  const GetBlankGrid = (wallPercent:number):boolean[] => {\r\n    let array:boolean[] = []\r\n    for(let i = 0; i < rows*columns; i++){\r\n      array[i] = (Math.random() >= (1 - (wallPercent/100)))\r\n    }\r\n    return array\r\n  }\r\n  const CleanGrid = () => {\r\n    const ne = document.getElementsByClassName('node') as HTMLCollectionOf<HTMLElement>\r\n    for(let i = 0; i < ne.length; i++){\r\n      const tempClassNames = []\r\n      for(let j = 0; j < ne[i].classList.length; j++){\r\n        if(ne[i].classList[j] === 'node') tempClassNames.push('node')\r\n        if(ne[i].classList[j] === 'start') tempClassNames.push('start')\r\n        if(ne[i].classList[j] === 'finish') tempClassNames.push('finish')\r\n        if(ne[i].classList[j] === 'wall') tempClassNames.push('wall')\r\n      }\r\n      ne[i].className = tempClassNames.join(\" \")\r\n    }\r\n  }\r\n  const StartSearch = () => {\r\n    startSearch(true)\r\n    CleanGrid()\r\n    var animations:Animation[] = []\r\n    if(algorithm === 'astar') animations = AStarSearch(grid,columns,startNode,finishNode,false)\r\n    if(algorithm === 'dijkstra') animations = Dijkstra(grid, columns,startNode,finishNode)\r\n    if(algorithm === 'best-first') animations = BestFirstSearch(grid, columns,startNode,finishNode)\r\n    if(algorithm === 'depth-first') animations = DepthFirstSearch(grid, columns,startNode,finishNode)\r\n    if(algorithm === 'breadth-first') animations = Dijkstra(grid, columns,startNode,finishNode)\r\n    const ne = document.getElementsByClassName('node') as HTMLCollectionOf<HTMLElement>\r\n    for(let i = 0; i < animations.length; i++){\r\n      setTimeout(() => {\r\n        ne[animations[i].index].className += animations[i].className\r\n        if(i === animations.length - 1) startSearch(false)\r\n      }, i * speed)\r\n    }\r\n    hasSolution.current = true\r\n  }\r\n  const StartSearchInstant = () => {\r\n    var animations:Animation[] = []\r\n    if(algorithm === 'astar') animations = AStarSearch(grid,columns,startNode,finishNode,false)\r\n    if(algorithm === 'dijkstra') animations = Dijkstra(grid, columns,startNode,finishNode)\r\n    if(algorithm === 'best-first') animations = BestFirstSearch(grid, columns,startNode,finishNode)\r\n    if(algorithm === 'depth-first') animations = DepthFirstSearch(grid, columns,startNode,finishNode)\r\n    if(algorithm === 'breadth-first') animations = Dijkstra(grid, columns,startNode,finishNode)\r\n    const ne = document.getElementsByClassName('node') as HTMLCollectionOf<HTMLElement>\r\n    for(let i = 0; i < animations.length; i++){\r\n      ne[animations[i].index].className += animations[i].className+\"Instant\"\r\n    }\r\n  }\r\n\r\n  const[grid,setGrid] = useState( () => GetBlankGrid(0))\r\n  const[startNode,setStartNode] = useState((rows*columns-1)-Math.floor(columns/2))\r\n  const[finishNode,setFinishNode] = useState(Math.floor(columns/2))\r\n  const[nodeDimensions,setNodeDimensions] = useState(50)\r\n\r\n  const mouseStatus = useRef(false)\r\n  const startMoveStatus = useRef(false)\r\n  const finishMoveStatus = useRef(false)\r\n  const mouseIndex = useRef(-1)\r\n  const hasSolution = useRef(false)\r\n  const algorithm = useSelector((state: RootStore) => state.algoSelect)\r\n  const solving = useSelector((state: RootStore) => state.startSearch)\r\n  const tiltState = useSelector((state: RootStore) => state.tiltState)\r\n  const speed = useSelector((state:RootStore) => state.searchSpeed)\r\n  const boardChange = useSelector((state:RootStore) => state.boardChange)\r\n\r\n  grid[startNode] = false\r\n  grid[finishNode] = false\r\n\r\n  useEffect( () => {\r\n    if(tiltState){\r\n      setNodeDimensions(50)    \r\n      setStartNode((rows*columns-1)-Math.floor(columns/2))\r\n      setFinishNode(Math.floor(columns/2))\r\n    } \r\n    else{\r\n      const nodeWidth = (window.innerWidth - 200) / columns\r\n      setNodeDimensions(nodeWidth) \r\n    }\r\n  },[tiltState])\r\n\r\n  useEffect( () => {\r\n    if(solving) StartSearch()\r\n  },[solving])\r\n\r\n  useEffect( () => {\r\n    if(hasSolution.current){\r\n      CleanGrid()\r\n      StartSearchInstant()\r\n    }\r\n  },[startNode,finishNode])\r\n\r\n  useEffect(() => {\r\n    if(boardChange.clearBoard) {\r\n      CleanGrid()\r\n      HideHiddenWalls(0)\r\n    }\r\n    else if(boardChange.clearPath){\r\n      CleanGrid()\r\n      hasSolution.current = false\r\n    } \r\n    else if(boardChange.randomWalls){\r\n      CleanGrid()\r\n      HideHiddenWalls(30)\r\n    }\r\n  },[boardChange])\r\n\r\n  return (\r\n    <div className=\"grid-container\">\r\n      <div className='grid' style = {{\r\n        marginTop: `${tiltState ? '-314px' : '0px'}`,\r\n        transform: `${tiltState ? 'perspective(800px) rotateX(60deg)' : ''}`,\r\n        gridTemplateColumns: `repeat(${columns},auto)`\r\n      }}>\r\n        {grid.map( (_,idx) => {\r\n          return(\r\n            <div className={[\r\n              'node',\r\n              `${idx === startNode ? 'start' : ''}`,\r\n              `${idx === finishNode ? 'finish' : ''}`,\r\n              `${grid[idx] ? 'wall' : ''}`\r\n            ].join(\" \")} \r\n            key={idx}\r\n            onMouseDown = { () => HandleMouseDown(idx)}\r\n            onMouseEnter = { () => HandleMouseEnter(idx)} \r\n            style={{\r\n              width: `${nodeDimensions}px`,\r\n              height: `${nodeDimensions}px`, \r\n            }}>\r\n            </div> \r\n          )\r\n        })}\r\n      </div>\r\n    </div>\r\n  );\r\n}\r\nexport default Grid;","import React from 'react';\r\nimport './App.css';\r\nimport Header from './components/header/header';\r\nimport Grid from './components/grid/grid';\r\nimport { useDispatch } from 'react-redux';\r\nimport { changeAlgo } from './Reducers/algoSelect/algoSelectActions';\r\nimport { startSearch } from './Reducers/startSearch/startSearchActions'\r\nimport { gridTilt } from './Reducers/gridTilt/gridTiltActions'\r\nimport { searchSpeed } from './Reducers/searchSpeed/searchSpeedActions';\r\nimport { boardCommands, boardCommand } from './Reducers/boardChange/boardChangeAction'\r\n\r\nfunction App() {\r\n  \r\n  const dispatch = useDispatch()\r\n\r\n  const onAlgoChange = (algo:string) => {\r\n    dispatch(changeAlgo(algo))\r\n  }\r\n\r\n  const onStartSearch = (start:boolean) => {\r\n    dispatch(startSearch(start))\r\n  }\r\n\r\n  const onTiltChange = (tilt:boolean) => {\r\n    dispatch(gridTilt(tilt))\r\n  }\r\n\r\n  const onSearchSpeed = (speed:number) => {\r\n    dispatch(searchSpeed(speed))\r\n  }\r\n\r\n  const onBoardCommand = (state:boolean, action:boardCommands) => {\r\n    dispatch(boardCommand(state,action))\r\n  }\r\n\r\n  return (\r\n    <div className=\"App\">\r\n      <Header \r\n        changeAlgo={onAlgoChange} \r\n        startSearch={onStartSearch} \r\n        gridTilt={onTiltChange}\r\n        searchSpeed={onSearchSpeed}\r\n        boardCommand={onBoardCommand}\r\n        />\r\n      <Grid startSearch={onStartSearch}/>\r\n    </div>\r\n  );\r\n}\r\n\r\nexport default App;","export type startSearchAction = {\r\n    type: \"START_SEARCH\",\r\n    payload: boolean\r\n}\r\n\r\nexport const startSearch = (start:boolean):startSearchAction => ({\r\n    type: \"START_SEARCH\",\r\n    payload: start\r\n})","export type algoSelectAction = {\r\n    type: \"CHANGE_ALGORITHM\",\r\n    payload: string\r\n}\r\n\r\nexport const changeAlgo = (algo:string):algoSelectAction => ({\r\n    type: \"CHANGE_ALGORITHM\",\r\n    payload: algo\r\n})","export type gridTiltAction = {\r\n    type: \"CHANGE_TILT_STATE\",\r\n    payload: boolean\r\n}\r\n\r\nexport const gridTilt = (tilt:boolean):gridTiltAction => ({\r\n    type: 'CHANGE_TILT_STATE',\r\n    payload: tilt\r\n})","export type searchSpeedAction = {\r\n    type: \"CHANGE_SPEED\",\r\n    payload: number\r\n}\r\n\r\nexport const searchSpeed = (speed:number):searchSpeedAction => ({\r\n    type: 'CHANGE_SPEED',\r\n    payload: speed\r\n})","export type clearPathAction = {\r\n    type: \"CLEAR_PATH\",\r\n    payload: boolean\r\n}\r\n\r\nexport type clearBoardAction = {\r\n    type: \"CLEAR_BOARD\",\r\n    payload: boolean\r\n}\r\n\r\nexport type randomWallsAction = {\r\n    type: \"RANDOM_WALLS\",\r\n    payload: boolean\r\n}\r\n\r\nexport const boardCommand = (state:boolean, command:boardCommands):boardCommandDispatchTypes => ({\r\n    type: command,\r\n    payload: state\r\n})\r\n\r\nexport type boardCommands = \"CLEAR_PATH\" | \"CLEAR_BOARD\" | \"RANDOM_WALLS\"\r\n\r\nexport type boardCommandDispatchTypes = clearPathAction | clearBoardAction | randomWallsAction","import { boardCommandDispatchTypes, clearBoardAction, clearPathAction, randomWallsAction } from './boardChangeAction'\r\n\r\ninterface IDefaultState{\r\n    clearBoard: boolean,\r\n    clearPath: boolean,\r\n    randomWalls: boolean\r\n}\r\n\r\nconst initState:IDefaultState = {\r\n    clearBoard: false,\r\n    clearPath: false,\r\n    randomWalls: false\r\n}\r\n\r\nexport const boardChangeReducer = (state:IDefaultState = initState, action: boardCommandDispatchTypes ): IDefaultState => {\r\n    switch(action.type){\r\n        case 'CLEAR_BOARD':\r\n            return {\r\n                clearBoard: true,\r\n                clearPath: false,\r\n                randomWalls: false\r\n            }\r\n        case 'CLEAR_PATH':\r\n            return {\r\n                clearBoard: false,\r\n                clearPath: true,\r\n                randomWalls: false\r\n            }\r\n        case 'RANDOM_WALLS':\r\n            return {\r\n                clearBoard: false,\r\n                clearPath: false,\r\n                randomWalls: true\r\n            }\r\n        default:\r\n            return state\r\n    }\r\n}","import { createStore, combineReducers } from 'redux'\r\nimport { algoSelectReducer } from './Reducers/algoSelect/algoSelectReducer'\r\nimport { startSearchReducer } from './Reducers/startSearch/startSearchReducer'\r\nimport { tiltStateReducer } from './Reducers/gridTilt/gridTiltReducer'\r\nimport { searchSpeedReducer } from './Reducers/searchSpeed/searchSpeedReducer'\r\nimport { boardChangeReducer } from './Reducers/boardChange/boardChangeReducer'\r\n \r\nconst rootReducer = combineReducers({\r\n    algoSelect: algoSelectReducer,\r\n    startSearch: startSearchReducer,\r\n    tiltState: tiltStateReducer,\r\n    searchSpeed: searchSpeedReducer,\r\n    boardChange: boardChangeReducer\r\n    })\r\n\r\nexport type RootStore = ReturnType<typeof rootReducer>\r\n\r\nexport const store = createStore(rootReducer)","import { algoSelectAction } from './algoSelectActions'\r\n\r\nconst initialState = 'astar'\r\n\r\nexport const algoSelectReducer = (state:string = initialState, action:algoSelectAction) => {\r\n    switch(action.type){\r\n        case \"CHANGE_ALGORITHM\":{\r\n            return action.payload\r\n        }\r\n        default: \r\n            return state\r\n    }\r\n}","import { startSearchAction } from './startSearchActions'\r\n\r\nconst initialState = false\r\n\r\nexport const startSearchReducer = (state:boolean = initialState, action:startSearchAction) => {\r\n    switch(action.type){\r\n        case \"START_SEARCH\" :{\r\n            return action.payload\r\n        }\r\n        default: \r\n            return state\r\n    }\r\n}","import { gridTiltAction } from './gridTiltActions'\r\n\r\nconst initialState = true\r\n\r\nexport const tiltStateReducer = (state:boolean = initialState, action:gridTiltAction) => {\r\n    switch(action.type){\r\n        case 'CHANGE_TILT_STATE' :{\r\n            return action.payload\r\n        }\r\n        default: \r\n            return state\r\n    }\r\n}","import { searchSpeedAction } from './searchSpeedActions'\r\n\r\nconst initState = 10\r\n\r\nexport const searchSpeedReducer = (state:number = initState, action:searchSpeedAction) => {\r\n    switch(action.type){\r\n        case \"CHANGE_SPEED\":\r\n            return action.payload\r\n        default:\r\n            return state\r\n    }\r\n}","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport App from './App';\nimport { Provider } from 'react-redux'\nimport { store } from './store'\n \nReactDOM.render(\n  <Provider store={store}>\n    <App />\n  </Provider>,\n  document.getElementById('root')\n);\n"],"sourceRoot":""}