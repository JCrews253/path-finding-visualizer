{"version":3,"sources":["algorithms/dijkstras/index.ts","algorithms/bestFirst/index.ts","components/header/header.tsx","algorithms/astar/index.ts","algorithms/depthFirst/index.ts","algorithms/breadthFirst/index.ts","components/grid/grid.tsx","App.tsx","Reducers/startSearch/startSearchActions.ts","Reducers/algoSelect/algoSelectActions.ts","Reducers/gridTilt/gridTiltActions.ts","Reducers/searchSpeed/searchSpeedActions.ts","Reducers/boardChange/boardChangeAction.ts","Reducers/boardChange/boardChangeReducer.ts","store.ts","Reducers/algoSelect/algoSelectReducer.ts","Reducers/startSearch/startSearchReducer.ts","Reducers/gridTilt/gridTiltReducer.ts","Reducers/searchSpeed/searchSpeedReducer.ts","index.tsx"],"names":["animationQueue","size","Header","changeAlgo","startSearch","gridTilt","searchSpeed","boardCommand","tilt","useSelector","state","tiltState","className","htmlFor","onChange","e","document","getElementById","algoritm","options","selectedIndex","value","onAlgoChange","id","onClick","window","open","speed","speedValue","onSearchSpeed","BuildNodeGrid","grid","buildNodeGrid","map","_","idx","isWall","gWeight","Infinity","hWeight","fWeight","parent","index","EuclideanDistance","p","q","width","pCol","pRow","Math","floor","qCol","qRow","sqrt","pow","ManhattanDistance","abs","FindSmallestCost","array","smallestIndex","ListContains","nodeList","length","i","ListRemove","gridIndex","splice","CalcNodeCosts","nodeGrid","nodeIndex","closedNodes","openNodes","start","finish","allowDiagonals","UpdateWeightCost","parentIndex","push","tempNode","this","FindMinNode","sptSet","distance","FindNodeDistances","heap","Swap","index1","index2","temp","HeapInsert","item","Parent","current","fcost","HeapRemove","first","newHeap","slice","LeftChild","RightChild","HasLeftChild","HasRightChild","currentIndex","smallerIndex","Heapify","AddSurrondingNodes","visited","searchStack","searchQueue","Enqueue","node","Dequeue","shift","inQueue","Grid","onmousedown","type","mouseStatus","onmouseup","startMoveStatus","finishMoveStatus","onresize","HideHiddenWalls","nodeWidth","innerWidth","setNodeDimensions","wallPercent","ne","getElementsByClassName","newGrid","location","getBoundingClientRect","x","y","innerHeight","random","setGrid","CleanGrid","tempClassNames","j","classList","join","StartSearch","a","request","algorithm","startNode","finishNode","fetch","method","mode","headers","body","JSON","stringify","response","json","animations","setTimeout","hasSolution","StartSearchInstant","currentNode","reverseQueue","pop","console","log","AStarSearch","Array","fill","Dijkstra","BestFirstSearch","DepthFirstSearch","BreadthFirstSearch","EstablishServerConnection","serverStatus","useRef","useState","rows","GetBlankGrid","columns","setStartNode","setFinishNode","nodeDimensions","mouseIndex","algoSelect","solving","boardChange","useEffect","clearBoard","clearPath","randomWalls","style","marginTop","transform","gridTemplateColumns","key","onMouseDown","HandleMouseDown","onMouseEnter","HandleMouseEnter","height","App","dispatch","useDispatch","onStartSearch","payload","algo","action","command","initState","rootReducer","combineReducers","store","createStore","ReactDOM","render"],"mappings":"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","file":"static/js/main.a79fe50e.chunk.js","sourcesContent":["import { Animation } from '../astar/index'\r\n\r\nexport interface Node{\r\n    isWall: boolean,\r\n    distance: number,\r\n    parent: number, \r\n    index: number\r\n}\r\n\r\nvar animationQueue: Animation[]\r\n\r\nexport const Dijkstra = (grid:boolean[],width:number,start:number,finish:number):Animation[] =>{\r\n    animationQueue = []\r\n    const sptSet:boolean[] =new Array(grid.length).fill(false)\r\n    const nodeGrid:Node[] = new Array(grid.length)\r\n    for(let i=0; i< nodeGrid.length; i++){\r\n        nodeGrid[i] = {\r\n            isWall: grid[i] ? true : false,\r\n            distance: Infinity,\r\n            parent: -1,\r\n            index: i\r\n        }\r\n        sptSet[i] = nodeGrid[i].isWall\r\n    }\r\n    nodeGrid[start] = {\r\n        ...nodeGrid[start],\r\n        distance:0,\r\n        parent:start\r\n    }\r\n    while(!sptSet[finish]){\r\n        var currentNode = nodeGrid[FindMinNode(nodeGrid,sptSet,finish)]\r\n        animationQueue.push({index: currentNode.index, className: ' searched'})\r\n        FindNodeDistances(nodeGrid,sptSet,currentNode.index,width)\r\n        sptSet[currentNode.index] = true\r\n    }\r\n\r\n    var parent = nodeGrid[finish].parent  \r\n    if(parent !== -1){\r\n        var reverseQueue:Animation[] = [] \r\n        while(parent !== nodeGrid[parent].parent){\r\n            reverseQueue.push({index: parent, className: ' shortestPath'})\r\n            parent = nodeGrid[parent].parent\r\n        }\r\n        while(reverseQueue.length > 0) animationQueue.push(reverseQueue.pop() as Animation)\r\n    }\r\n    else \r\n    {\r\n        console.log('No Path Found')\r\n    }\r\n    return animationQueue\r\n}\r\n\r\nexport const FindMinNode = (nodeGrid:Node[], sptSet:boolean[],finish:number):number => {\r\n    let smallestIndex = finish\r\n    nodeGrid.map( (_,idx) => {\r\n        if(nodeGrid[idx].distance < nodeGrid[smallestIndex].distance && !sptSet[idx]){\r\n            smallestIndex = idx\r\n        }\r\n    })\r\n    return smallestIndex\r\n}\r\n\r\nexport const FindNodeDistances = (nodeGrid:Node[], sptSet:boolean[],nodeIndex:number, width:number) => {\r\n    const UpdateWeightCost = (index:number, parentIndex:number) => {\r\n        if(!nodeGrid[index].isWall && !sptSet[index]){\r\n            nodeGrid[index] = {\r\n                ...nodeGrid[index],\r\n                distance: nodeGrid[parentIndex].distance + 1,\r\n                parent: parentIndex\r\n            }\r\n            animationQueue.push({\r\n                index:index,\r\n                className: ' openList'\r\n            })\r\n        }\r\n    }\r\n\r\n    //Top\r\n    if(nodeIndex >= width){\r\n        UpdateWeightCost(nodeIndex-width,nodeIndex)\r\n    }\r\n    //Right\r\n    if(nodeIndex % width !== width-1){\r\n       UpdateWeightCost(nodeIndex+1,nodeIndex)\r\n    }\r\n    //Bottom\r\n    if(nodeIndex < nodeGrid.length - width){\r\n       UpdateWeightCost(nodeIndex+width,nodeIndex)\r\n    }\r\n    //Left\r\n    if(nodeIndex % width !== 0){\r\n       UpdateWeightCost(nodeIndex-1,nodeIndex)\r\n    }\r\n}","import { Animation } from '../astar/index'\r\n\r\nvar animationQueue: Animation[] = []\r\nvar heap:Node[] = []\r\nvar size: number\r\n\r\ninterface Node {\r\n    isWall: boolean,\r\n    visited: boolean,\r\n    fcost: number,\r\n    parent: number, \r\n    index: number\r\n}\r\n\r\nexport const BestFirstSearch = (grid:boolean[],width:number,start:number,finish:number):Animation[] => {\r\n    animationQueue = []\r\n    heap = []\r\n    size = 0\r\n    const nodeGrid:Node[] = new Array(grid.length)\r\n    for(let i=0;i<grid.length;i++){\r\n        nodeGrid[i] = {\r\n            isWall: grid[i],\r\n            visited: false,\r\n            fcost: (i === start) ? ManhattanDistance(i,finish,width): Infinity,\r\n            parent: (i === start)? start : -1,\r\n            index: i\r\n        }\r\n    }\r\n\r\n    HeapInsert(nodeGrid[start])\r\n\r\n    while(heap.length > 0 && heap.length < width * 20){\r\n        const currentNode = HeapRemove()\r\n        nodeGrid[currentNode.index] = { \r\n            ...currentNode,\r\n            visited: true,\r\n        }\r\n        animationQueue.push({\r\n            index:currentNode.index,\r\n            className: ' searched'\r\n        })\r\n        if(currentNode.index === finish) break\r\n        else AddSurrondingNodes(nodeGrid,currentNode.index,width,finish)\r\n    }\r\n\r\n    var parent = nodeGrid[finish].parent  \r\n    if(parent !== -1){\r\n        var reverseQueue:Animation[] = [] \r\n        while(parent !== nodeGrid[parent].parent){\r\n            reverseQueue.push({index: parent, className: ' shortestPath'})\r\n            parent = nodeGrid[parent].parent\r\n        }\r\n        while(reverseQueue.length > 0) animationQueue.push(reverseQueue.pop() as Animation)\r\n    }\r\n    else \r\n    {\r\n        console.log('No Path Found')\r\n    }\r\n    return animationQueue\r\n}\r\n\r\nexport const Heapify = (index:number) => {\r\n    const LeftChild = (index: number):number => Math.floor(2*index+1) \r\n    const RightChild = (index: number):number => Math.floor(2*index+2)\r\n    const HasLeftChild = (index: number):boolean => LeftChild(index) < size\r\n    const HasRightChild = (index: number):boolean => RightChild(index) < size\r\n\r\n    var currentIndex = index\r\n    while(HasLeftChild(currentIndex)){    \r\n        var smallerIndex = LeftChild(currentIndex)\r\n        if(HasRightChild(currentIndex) && \r\n        heap[RightChild(currentIndex)].fcost < heap[LeftChild(currentIndex)].fcost){\r\n            smallerIndex = RightChild(currentIndex)\r\n        }\r\n        if(heap[currentIndex].fcost < heap[smallerIndex].fcost) break\r\n        else Swap(currentIndex, smallerIndex)\r\n        currentIndex = smallerIndex\r\n    }\r\n}\r\n\r\nexport const Swap = (index1:number, index2:number) => {\r\n    const temp = heap[index1]\r\n    heap[index1] = heap[index2]\r\n    heap[index2] = temp\r\n}\r\n\r\nexport const HeapInsert = (item:Node) => {\r\n    const Parent = (index: number):number => Math.floor((index - 1) / 2)\r\n    const HasParent = (index: number):boolean => Parent(index) >= 0\r\n    heap[size] = item\r\n    size++\r\n    var current = size - 1 \r\n    while(HasParent(current) && (heap[current].fcost < heap[Parent(current)].fcost)){\r\n        Swap(current,Parent(current))\r\n        current = Parent(current)\r\n    }\r\n}\r\n\r\nexport const HeapRemove = ():Node => {\r\n    const first = heap[0]\r\n    heap[0] = heap[size - 1]\r\n    const newHeap = heap.slice(0,size-1)\r\n    heap = [...newHeap]\r\n    size--\r\n    Heapify(0)\r\n    return first\r\n}\r\n\r\nexport const ManhattanDistance = (p:number, q:number, width: number):number => {\r\n    const pRow = Math.floor(p/width)\r\n    var pCol\r\n    if(p >= width) pCol = p % width\r\n    else pCol = p\r\n    const qRow = Math.floor(q/width)\r\n    var qCol\r\n    if(q >= width) qCol = q % width\r\n    else qCol = q\r\n    return Math.floor((Math.abs(qRow - pRow) + Math.abs(qCol - pCol))*10)  \r\n}\r\n\r\nexport const AddSurrondingNodes = (nodeGrid:Node[],nodeIndex:number, width:number,finish:number) => {\r\n    const UpdateWeightCost = (index:number, parentIndex:number) => {\r\n        if(!nodeGrid[index].isWall && !nodeGrid[index].visited && nodeGrid[index].fcost === Infinity){\r\n            nodeGrid[index] = {\r\n                ...nodeGrid[index],\r\n                fcost: ManhattanDistance(index,finish,width),\r\n                parent: parentIndex\r\n            }\r\n            animationQueue.push({\r\n                index:index,\r\n                className: ' openList'\r\n            })\r\n            HeapInsert(nodeGrid[index])\r\n        }\r\n    }\r\n\r\n    //Top\r\n    if(nodeIndex >= width){\r\n        UpdateWeightCost(nodeIndex-width,nodeIndex)\r\n    }\r\n    //Right\r\n    if(nodeIndex % width !== width-1){\r\n       UpdateWeightCost(nodeIndex+1,nodeIndex)\r\n    }\r\n    //Bottom\r\n    if(nodeIndex < nodeGrid.length - width){\r\n       UpdateWeightCost(nodeIndex+width,nodeIndex)\r\n    }\r\n    //Left\r\n    if(nodeIndex % width !== 0){\r\n       UpdateWeightCost(nodeIndex-1,nodeIndex)\r\n    }\r\n}","import React from 'react'\r\nimport './header.css'\r\nimport { useSelector } from 'react-redux'\r\nimport { RootStore } from '../../store';\r\nimport {boardCommands} from '../../Reducers/boardChange/boardChangeAction'\r\n\r\ninterface IHeaderInputProps{\r\n    changeAlgo(algo:string): void,\r\n    startSearch(start:boolean): void,\r\n    gridTilt(tilt:boolean): void,\r\n    searchSpeed(speed:number): void,\r\n    boardCommand(state:boolean, action:boardCommands): void\r\n}\r\n\r\nconst Header: React.FC<IHeaderInputProps> = ({changeAlgo, startSearch, gridTilt,searchSpeed, boardCommand}) => {\r\n    const tilt = useSelector( (state:RootStore) => state.tiltState)\r\n\r\n    const onAlgoChange = () => {\r\n        const e = document.getElementById('algo-select') as HTMLSelectElement\r\n        const algoritm = e.options[e.selectedIndex].value\r\n        changeAlgo(algoritm)\r\n    }\r\n\r\n    const onStartSearch = () => {\r\n        startSearch(true)\r\n    }\r\n\r\n    const onGridTilt = () => {\r\n        gridTilt(tilt ? false : true)\r\n    }\r\n\r\n    const onSearchSpeed = () => {\r\n        const e = document.getElementById('speed-select') as HTMLSelectElement\r\n        const speed = e.options[e.selectedIndex].value\r\n        var speedValue = 10\r\n        if(speed === \"FAST\") speedValue = 10\r\n        if(speed === \"MEDIUM\") speedValue = 50\r\n        if(speed === \"SLOW\") speedValue = 100\r\n        searchSpeed(speedValue)\r\n    }\r\n    \r\n    const HandleGitHubClick = () => {\r\n        window.open(\"https://github.com/JCrews253/path-finding-visualizer\")\r\n    }\r\n\r\n    const solving = useSelector((state: RootStore) => state.startSearch)\r\n\r\n    return(\r\n        <div className='header'>\r\n            <h1 className='title'>Retro 80's Path Finding Visualization</h1>\r\n            <div className='label-element-container'>\r\n                <label className='algo-select-label' htmlFor='algo-select'>Choose an Algorithm:</label>\r\n                <select onChange={() => onAlgoChange()} id='algo-select'>\r\n                    <option value='astar'>A* Search</option>\r\n                    <option value='dijkstra'>Dijkstra's Algorithm</option>\r\n                    <option value='best-first'>Best First Search</option>\r\n                    <option value='depth-first'>Depth First Search</option>\r\n                    <option value='breadth-first'>Breadth First Search</option>\r\n                </select>\r\n            </div>\r\n            <div className='buttons-container'>\r\n                <button className='animated-button'>Home</button>\r\n                <button className='animated-button' onClick={()=> HandleGitHubClick()}>Github</button>\r\n                <hr/>\r\n                <button className='animated-button' onClick={() => onStartSearch()}>Start</button>\r\n                <button className='animated-button'onClick={() => boardCommand(true,\"CLEAR_PATH\")}>Clear Path</button>\r\n                <button className='animated-button'onClick={() => boardCommand(true,\"CLEAR_BOARD\")}>Clear Board</button>\r\n                <button className='animated-button'onClick={() => boardCommand(true,\"RANDOM_WALLS\")}>Random Walls</button>\r\n                <button className='animated-button' onClick={() => onGridTilt()}>Toggle Tilt</button>\r\n            </div>\r\n            <div className='label-element-container'>\r\n                <label className='speed-select-label' htmlFor='speed-select'>Choose Search Speed</label>\r\n                <select onChange={() => onSearchSpeed()} id='speed-select'>\r\n                    <option value='FAST'>Fast</option>\r\n                    <option value='MEDIUM'>Medium</option>\r\n                    <option value='SLOW'>Slow</option>\r\n                </select>\r\n            </div>\r\n        </div>\r\n    )\r\n}\r\n\r\nexport default Header","import '../../App.css'\r\n\r\nexport interface Node{\r\n    isWall: boolean,\r\n    gWeight: number,\r\n    hWeight: number,\r\n    fWeight: number,\r\n    parent: number, \r\n    index: number\r\n}\r\n\r\nexport interface Animation{\r\n    index: number,\r\n    className: string\r\n}\r\n\r\nvar animationQueue: Animation[] = []\r\n\r\nexport const AStarSearch = (grid: boolean[], width: number, start:number, finish: number, allowDiagonals: boolean):Animation[] => {\r\n    animationQueue = []\r\n    const openNodes: Node[] = []\r\n    const closedNodes:Node[] = []\r\n    const nodeGrid = [...BuildNodeGrid(grid)]\r\n\r\n    nodeGrid[start] = {\r\n        ...nodeGrid[start],\r\n        gWeight: 0,\r\n        hWeight: 0,\r\n        fWeight: 0,\r\n        parent: start\r\n    } \r\n    openNodes.push(nodeGrid[start])\r\n\r\n    while(openNodes.length > 0){\r\n        var currentNode = nodeGrid[FindSmallestCost(openNodes)]\r\n        if(currentNode.index !== start && currentNode.index !== finish) animationQueue.push({index: currentNode.index, className: ' searched'})\r\n        ListRemove(openNodes,currentNode.index)\r\n        closedNodes.push(currentNode)\r\n        if(currentNode.index === finish) break;\r\n        CalcNodeCosts(nodeGrid, currentNode.index, closedNodes, openNodes, start, finish, width, allowDiagonals)\r\n    }\r\n\r\n    var parent = nodeGrid[finish].parent\r\n    \r\n    if(parent !== -1){\r\n        var reverseQueue:Animation[] = [] \r\n        while(parent !== nodeGrid[parent].parent){\r\n            reverseQueue.push({index: parent, className: ' shortestPath'})\r\n            parent = nodeGrid[parent].parent\r\n        }\r\n        while(reverseQueue.length > 0) animationQueue.push(reverseQueue.pop() as Animation)\r\n    }\r\n    else \r\n    {\r\n        console.log('No Path Found')\r\n    }\r\n\r\n\r\n    return animationQueue\r\n}\r\n\r\nexport const BuildNodeGrid = (grid: boolean[]):Node[] => {\r\n    const buildNodeGrid:Node[] = []\r\n    grid.map( (_,idx) => {\r\n        buildNodeGrid[idx] = {\r\n            isWall: (grid[idx] === true) ? true : false,\r\n            gWeight: Infinity,\r\n            hWeight: Infinity,\r\n            fWeight: Infinity,\r\n            parent: -1,\r\n            index: idx,\r\n        }\r\n    })\r\n   return buildNodeGrid\r\n}\r\n\r\nexport const EuclideanDistance = (p:number, q:number, width: number):number => {\r\n    const pRow = Math.floor(p/width)\r\n    var pCol\r\n    if(p >= width) pCol = p % width\r\n    else pCol = p\r\n    const qRow = Math.floor(q/width)\r\n    var qCol\r\n    if(q >= width) qCol = q % width\r\n    else qCol = q\r\n    return Math.floor(Math.sqrt(Math.pow(qRow - pRow,2) + Math.pow(qCol - pCol,2))*10)  \r\n}\r\n\r\nexport const ManhattanDistance = (p:number, q:number, width: number):number => {\r\n    const pRow = Math.floor(p/width)\r\n    var pCol\r\n    if(p >= width) pCol = p % width\r\n    else pCol = p\r\n    const qRow = Math.floor(q/width)\r\n    var qCol\r\n    if(q >= width) qCol = q % width\r\n    else qCol = q\r\n    return Math.floor((Math.abs(qRow - pRow) + Math.abs(qCol - pCol))*10)  \r\n}\r\n\r\nexport const FindSmallestCost = (array:Node[]):number => {\r\n    let smallestIndex = 0\r\n    array.map( (_,idx) => {\r\n        if(array[idx].fWeight < array[smallestIndex].fWeight){\r\n            smallestIndex = idx\r\n        }\r\n        else if (array[idx].fWeight === array[smallestIndex].fWeight && array[idx].hWeight < array[smallestIndex].hWeight){\r\n            smallestIndex = idx\r\n        }\r\n    })\r\n    return array[smallestIndex].index\r\n}\r\n\r\nexport const ListContains = (nodeList: Node[], index:number):boolean => {\r\n    if(nodeList.length === 0 ) return false\r\n    for(let i = 0; i < nodeList.length; i++ ){\r\n        if(nodeList[i].index === index) return true\r\n    }\r\n    return false\r\n}\r\n\r\nexport const ListRemove = (nodeList: Node[], gridIndex:number) => {\r\n    for(let i = 0; i < nodeList.length; i++){\r\n        if(nodeList[i].index === gridIndex){\r\n            nodeList.splice(i,1)\r\n            break\r\n        }\r\n    }\r\n}\r\n\r\nexport const CalcNodeCosts = (nodeGrid:Node[], nodeIndex:number, closedNodes:Node[],openNodes:Node[],start:number,finish:number, width:number, allowDiagonals:boolean) => {\r\n    const UpdateWeightCost = (index:number,parentIndex:number) => {\r\n        if(!nodeGrid[index].isWall && !ListContains(closedNodes,index)){\r\n            if(index !== finish){\r\n                animationQueue.push({\r\n                    index:index,\r\n                    className: ' openList'\r\n                })\r\n            }\r\n            const tempNode:Node = { ...nodeGrid[index],\r\n                gWeight: nodeGrid[parentIndex].gWeight + (allowDiagonals ? EuclideanDistance(index,parentIndex,width) : ManhattanDistance(index,parentIndex,width)),\r\n                hWeight: allowDiagonals ? EuclideanDistance(index,finish,width) : ManhattanDistance(index, finish, width),\r\n                get fWeight (){\r\n                    return this.gWeight + this.hWeight\r\n                },\r\n                parent: parentIndex\r\n            }\r\n            if(tempNode.fWeight < nodeGrid[index].fWeight || !ListContains(openNodes,index)){\r\n                nodeGrid[index] = tempNode\r\n                openNodes.push(nodeGrid[index])\r\n            }\r\n            else if( tempNode.fWeight === nodeGrid[index].fWeight && tempNode.hWeight < nodeGrid[index].hWeight){\r\n                nodeGrid[index] = tempNode\r\n                openNodes.push(nodeGrid[index])\r\n            }\r\n        }\r\n    }\r\n\r\n    //Top\r\n    if(nodeIndex >= width){\r\n        UpdateWeightCost(nodeIndex-width,nodeIndex)\r\n    }\r\n    //Top-Right\r\n    if(nodeIndex >= width && nodeIndex % width !== width-1 && allowDiagonals){\r\n       UpdateWeightCost(nodeIndex-width+1,nodeIndex)\r\n    }\r\n    //Right\r\n    if(nodeIndex % width !== width-1){\r\n       UpdateWeightCost(nodeIndex+1,nodeIndex)\r\n    }\r\n    //Bottom-Right\r\n    if(nodeIndex % width !== width-1 && nodeIndex < nodeGrid.length - width && allowDiagonals){\r\n       UpdateWeightCost(nodeIndex+width+1,nodeIndex)\r\n    }\r\n    //Bottom\r\n    if(nodeIndex < nodeGrid.length - width){\r\n       UpdateWeightCost(nodeIndex+width,nodeIndex)\r\n    }\r\n    //Bottom-Left\r\n    if(nodeIndex < nodeGrid.length - width && nodeIndex % width !== 0 && allowDiagonals){\r\n       UpdateWeightCost(nodeIndex+width-1,nodeIndex)\r\n    }\r\n    //Left\r\n    if(nodeIndex % width !== 0){\r\n       UpdateWeightCost(nodeIndex-1,nodeIndex)\r\n    }\r\n    //Top-Left\r\n    if(nodeIndex % width !== 0 && nodeIndex >= width && allowDiagonals){\r\n       UpdateWeightCost(nodeIndex-width-1,nodeIndex)\r\n    }\r\n}","import { Animation } from '../astar/index'\r\n\r\ninterface Node{\r\n    isWall:boolean,\r\n    visited:boolean,\r\n    parent:number,\r\n    index:number\r\n}\r\n\r\nvar animationQueue: Animation[] = []\r\nvar searchStack: Node[] = []\r\n\r\nexport const DepthFirstSearch = (grid:boolean[],width:number,start:number,finish:number):Animation[] => {\r\n    animationQueue = []\r\n    searchStack = []\r\n    const nodeGrid: Node[] = []\r\n    for(let i = 0;i<grid.length;i++){\r\n        nodeGrid[i] = {\r\n            isWall: grid[i],\r\n            visited: false,\r\n            parent: (i === start) ? start : -1,\r\n            index: i\r\n        }\r\n    }\r\n    \r\n    searchStack.push(nodeGrid[start])\r\n\r\n    while(searchStack.length > 0){\r\n        const currentNode = searchStack.pop() as Node\r\n        nodeGrid[currentNode.index] = {\r\n            ...currentNode,\r\n            visited: true\r\n        }\r\n        animationQueue.push({\r\n            index:currentNode.index,\r\n            className: ' searched'\r\n        })\r\n        if(currentNode.index === finish) break\r\n        else AddSurrondingNodes(nodeGrid,currentNode.index,width)\r\n    }\r\n\r\n    var parent = nodeGrid[finish].parent  \r\n    if(parent !== -1){\r\n        var reverseQueue:Animation[] = [] \r\n        while(parent !== nodeGrid[parent].parent){\r\n            reverseQueue.push({index: parent, className: ' shortestPath'})\r\n            parent = nodeGrid[parent].parent\r\n        }\r\n        while(reverseQueue.length > 0) animationQueue.push(reverseQueue.pop() as Animation)\r\n    }\r\n    else \r\n    {\r\n        console.log('No Path Found')\r\n    }\r\n    return animationQueue\r\n}\r\n\r\nexport const AddSurrondingNodes = (nodeGrid:Node[],nodeIndex:number, width:number) => {\r\n    const UpdateWeightCost = (index:number, parentIndex:number) => {\r\n        if(!nodeGrid[index].isWall && !nodeGrid[index].visited){\r\n            nodeGrid[index] = {\r\n                ...nodeGrid[index],\r\n                parent: parentIndex\r\n            }\r\n            animationQueue.push({\r\n                index:index,\r\n                className: ' openList'\r\n            })\r\n            searchStack.push(nodeGrid[index])\r\n        }\r\n    }\r\n\r\n    //Top\r\n    if(nodeIndex >= width){\r\n        UpdateWeightCost(nodeIndex-width,nodeIndex)\r\n    }\r\n    //Right\r\n    if(nodeIndex % width !== width-1){\r\n       UpdateWeightCost(nodeIndex+1,nodeIndex)\r\n    }\r\n    //Bottom\r\n    if(nodeIndex < nodeGrid.length - width){\r\n       UpdateWeightCost(nodeIndex+width,nodeIndex)\r\n    }\r\n    //Left\r\n    if(nodeIndex % width !== 0){\r\n       UpdateWeightCost(nodeIndex-1,nodeIndex)\r\n    }\r\n}","import { Animation } from '../astar/index'\r\n\r\ninterface Node{\r\n    isWall:boolean,\r\n    visited:boolean,\r\n    inQueue: boolean,\r\n    parent: number,\r\n    index: number,\r\n}\r\n\r\nvar animationQueue: Animation[] = []\r\nvar searchQueue:Node[] = []\r\n\r\nexport const BreadthFirstSearch = (grid:boolean[],width:number,start:number,finish:number):Animation[] => {\r\n    animationQueue = []\r\n    searchQueue = []\r\n    const nodeGrid:Node[] = []\r\n    for(let i=0;i<grid.length;i++){\r\n        nodeGrid[i] = {\r\n            isWall: grid[i],\r\n            visited: false,\r\n            inQueue: i === start,\r\n            parent: (i === start) ? start : -1,\r\n            index: i\r\n        }\r\n    }\r\n\r\n    Enqueue(nodeGrid[start])\r\n\r\n    while(searchQueue.length > 0){\r\n        console.log(searchQueue.length)\r\n        const currentNode = Dequeue()\r\n        nodeGrid[currentNode.index] ={\r\n            ...currentNode,\r\n            visited: true\r\n        }\r\n        animationQueue.push({\r\n            index:currentNode.index,\r\n            className: ' searched'\r\n        })\r\n        if(currentNode.index === finish) break\r\n        else AddSurrondingNodes(nodeGrid,currentNode.index,width)\r\n    }\r\n\r\n    var parent = nodeGrid[finish].parent  \r\n    if(parent !== -1){\r\n        var reverseQueue:Animation[] = [] \r\n        while(parent !== nodeGrid[parent].parent){\r\n            reverseQueue.push({index: parent, className: ' shortestPath'})\r\n            parent = nodeGrid[parent].parent\r\n        }\r\n        while(reverseQueue.length > 0) animationQueue.push(reverseQueue.pop() as Animation)\r\n    }\r\n    else \r\n    {\r\n        console.log('No Path Found')\r\n    }\r\n    return animationQueue\r\n}\r\n\r\nconst Enqueue = (node:Node) => searchQueue.push(node)\r\n\r\nconst Dequeue = ():Node => searchQueue.shift() as Node\r\n\r\nexport const AddSurrondingNodes = (nodeGrid:Node[],nodeIndex:number, width:number) => {\r\n    const UpdateWeightCost = (index:number, parentIndex:number) => {\r\n        if(!nodeGrid[index].isWall && !nodeGrid[index].visited && !nodeGrid[index].inQueue){\r\n            nodeGrid[index] = {\r\n                ...nodeGrid[index],\r\n                inQueue: true,\r\n                parent: parentIndex\r\n            }\r\n            animationQueue.push({\r\n                index:index,\r\n                className: ' openList'\r\n            })\r\n            Enqueue(nodeGrid[index])\r\n        }\r\n    }\r\n    //Top\r\n    if(nodeIndex >= width){\r\n        UpdateWeightCost(nodeIndex-width,nodeIndex)\r\n    }\r\n    //Right\r\n    if(nodeIndex % width !== width-1){\r\n       UpdateWeightCost(nodeIndex+1,nodeIndex)\r\n    }\r\n    //Bottom\r\n    if(nodeIndex < nodeGrid.length - width){\r\n       UpdateWeightCost(nodeIndex+width,nodeIndex)\r\n    }\r\n    //Left\r\n    if(nodeIndex % width !== 0){\r\n       UpdateWeightCost(nodeIndex-1,nodeIndex)\r\n    }\r\n}","import React, { useState, useRef, useEffect} from 'react';\r\nimport { AStarSearch, Animation } from '../../algorithms/astar'\r\nimport './grid.css'\r\nimport { useSelector } from 'react-redux';\r\nimport { RootStore } from '../../store';\r\nimport { Dijkstra } from '../../algorithms/dijkstras';\r\nimport { BestFirstSearch } from '../../algorithms/bestFirst';\r\nimport { DepthFirstSearch } from '../../algorithms/depthFirst';\r\nimport { BreadthFirstSearch } from '../../algorithms/breadthFirst';\r\n\r\ninterface IGridInputProps{\r\n  startSearch(start:boolean):void,\r\n}\r\n\r\ninterface requestDataI{\r\n  grid:boolean[],\r\n  width: number,\r\n  start: number,\r\n  finish:number\r\n}\r\n\r\nconst rows = 18\r\nconst columns = 63\r\n\r\nconst Grid:React.FC<IGridInputProps> = ({startSearch}) => {\r\n  window.onmousedown = (e:MouseEvent) => {\r\n    if(e.type === 'mousedown') mouseStatus.current = true\r\n  }\r\n  window.onmouseup = (e:MouseEvent) => {\r\n    if(e.type === 'mouseup') {\r\n      mouseStatus.current = false\r\n      startMoveStatus.current = false\r\n      finishMoveStatus.current = false\r\n    }\r\n  }\r\n  window.onresize = () => {\r\n    if(tiltState){\r\n      HideHiddenWalls(20)\r\n    }\r\n    else {\r\n      const nodeWidth = (window.innerWidth - 200) / columns\r\n      setNodeDimensions(nodeWidth) \r\n    }\r\n  }\r\n  const HideHiddenWalls = (wallPercent:number) => {\r\n    const ne = document.getElementsByClassName('node') as HTMLCollectionOf<HTMLElement>\r\n      const newGrid = [...grid]\r\n      for(let i = 0; i < ne.length; i++){\r\n        const location = ne[i].getBoundingClientRect()\r\n        if(location.x + (location.width / 2) < 0 || location.x > window.innerWidth - 50 || location.y > window.innerHeight){\r\n          newGrid[i] = true\r\n        }\r\n        else{\r\n          newGrid[i] = (Math.random() >= (1 - (wallPercent/100)))\r\n        }\r\n      }\r\n      setGrid(newGrid)\r\n  }\r\n  const HandleMouseDown = (index:number) => {\r\n    if(!solving){\r\n      if(index === startNode) startMoveStatus.current = true\r\n      else if(index === finishNode) finishMoveStatus.current = true\r\n      else{\r\n        mouseIndex.current = index\r\n        const newGrid = [...grid]\r\n        newGrid[index] = grid[index] ? false : true\r\n        setGrid(newGrid)\r\n      }\r\n    }\r\n  }\r\n  const HandleMouseEnter = (index:number) => {\r\n    if(!solving){\r\n      if(startMoveStatus.current){\r\n        setStartNode(index)\r\n      }\r\n      else if(finishMoveStatus.current){\r\n        setFinishNode(index)\r\n      }\r\n      else if(mouseStatus.current && index !== mouseIndex.current){\r\n        mouseIndex.current = index\r\n        const newGrid = [...grid]\r\n        newGrid[index] = grid[index] ? false : true\r\n        setGrid(newGrid)\r\n      }\r\n    }\r\n  }\r\n  const GetBlankGrid = (wallPercent:number):boolean[] => {\r\n    let array:boolean[] = []\r\n    for(let i = 0; i < rows*columns; i++){\r\n      array[i] = (Math.random() >= (1 - (wallPercent/100)))\r\n    }\r\n    return array\r\n  }\r\n  const CleanGrid = () => {\r\n    const ne = document.getElementsByClassName('node') as HTMLCollectionOf<HTMLElement>\r\n    for(let i = 0; i < ne.length; i++){\r\n      const tempClassNames = []\r\n      for(let j = 0; j < ne[i].classList.length; j++){\r\n        if(ne[i].classList[j] === 'node') tempClassNames.push('node')\r\n        if(ne[i].classList[j] === 'start') tempClassNames.push('start')\r\n        if(ne[i].classList[j] === 'finish') tempClassNames.push('finish')\r\n        if(ne[i].classList[j] === 'wall') tempClassNames.push('wall')\r\n      }\r\n      ne[i].className = tempClassNames.join(\" \")\r\n    }\r\n  }\r\n  const StartSearch = async () => {\r\n    startSearch(true)\r\n    CleanGrid()\r\n    \r\n    const request = {\r\n      algorithm: algorithm,\r\n      grid: grid,\r\n      width: columns,\r\n      start: startNode,\r\n      finish: finishNode\r\n    }\r\n\r\n    const response = await fetch(`https://path-finding-visualizer.herokuapp.com/solutions`, {\r\n      method: 'POST', // *GET, POST, PUT, DELETE, etc.\r\n      mode: 'cors', // no-cors, *cors, same-origin\r\n      headers: {\r\n        'Content-Type': 'application/json',\r\n        'Access-Control-Allow-Origin': '*',\r\n        'Access-Control-Allow-Headers':'*'\r\n      },\r\n      body: JSON.stringify(request) // body data type must match \"Content-Type\" header\r\n    })\r\n    const animations = await response.json() \r\n\r\n    const ne = document.getElementsByClassName('node') as HTMLCollectionOf<HTMLElement>\r\n    if(animations.length === 0) startSearch(false)\r\n    for(let i = 0; i < animations.length; i++){\r\n      setTimeout(() => {\r\n        ne[animations[i].index].className += animations[i].className\r\n        if(i === animations.length - 1) startSearch(false)\r\n      }, i * speed)\r\n    }\r\n    hasSolution.current = true\r\n  }\r\n  const StartSearchInstant = () => {\r\n    var animations:Animation[] = []\r\n    if(algorithm === 'astar') animations = AStarSearch(grid,columns,startNode,finishNode,false)\r\n    if(algorithm === 'dijkstra') animations = Dijkstra(grid, columns,startNode,finishNode)\r\n    if(algorithm === 'best-first') animations = BestFirstSearch(grid, columns,startNode,finishNode)\r\n    if(algorithm === 'depth-first') animations = DepthFirstSearch(grid, columns,startNode,finishNode)\r\n    if(algorithm === 'breadth-first') animations = BreadthFirstSearch(grid, columns,startNode,finishNode)\r\n    const ne = document.getElementsByClassName('node') as HTMLCollectionOf<HTMLElement>\r\n    for(let i = 0; i < animations.length; i++){\r\n      ne[animations[i].index].className += animations[i].className+\"Instant\"\r\n    }\r\n  }\r\n  const EstablishServerConnection = async() => {\r\n    const response = await fetch(`https://path-finding-visualizer.herokuapp.com/status`,{\r\n      method: 'GET', // *GET, POST, PUT, DELETE, etc.\r\n      mode: 'cors', // no-cors, *cors, same-origin\r\n      headers: {\r\n        'Content-Type': 'application/json',\r\n        'Access-Control-Allow-Origin': '*',\r\n        'Access-Control-Allow-Headers':'*'\r\n      }})\r\n    serverStatus.current = true\r\n    console.log('server connection')\r\n  }\r\n\r\n  const serverStatus = useRef(false)\r\n  const[grid,setGrid] = useState( () => GetBlankGrid(0))\r\n  const[startNode,setStartNode] = useState((rows*columns-1)-Math.floor(columns/2))\r\n  const[finishNode,setFinishNode] = useState(Math.floor(columns/2))\r\n  const[nodeDimensions,setNodeDimensions] = useState(50)\r\n\r\n  const mouseStatus = useRef(false)\r\n  const startMoveStatus = useRef(false)\r\n  const finishMoveStatus = useRef(false)\r\n  const mouseIndex = useRef(-1)\r\n  const hasSolution = useRef(false)\r\n  const algorithm = useSelector((state: RootStore) => state.algoSelect)\r\n  const solving = useSelector((state: RootStore) => state.startSearch)\r\n  const tiltState = useSelector((state: RootStore) => state.tiltState)\r\n  const speed = useSelector((state:RootStore) => state.searchSpeed)\r\n  const boardChange = useSelector((state:RootStore) => state.boardChange)\r\n\r\n  grid[startNode] = false\r\n  grid[finishNode] = false\r\n\r\n  if(serverStatus.current === false) EstablishServerConnection()\r\n\r\n  useEffect( () => {\r\n    if(tiltState){\r\n      setNodeDimensions(50)    \r\n      setStartNode((rows*columns-1)-Math.floor(columns/2))\r\n      setFinishNode(Math.floor(columns/2))\r\n    } \r\n    else{\r\n      const nodeWidth = (window.innerWidth - 200) / columns\r\n      setNodeDimensions(nodeWidth) \r\n    }\r\n  },[tiltState])\r\n\r\n  useEffect( () => {\r\n    if(solving) StartSearch()\r\n  },[solving])\r\n\r\n  useEffect( () => {\r\n    if(hasSolution.current){\r\n      CleanGrid()\r\n      StartSearchInstant()\r\n    }\r\n  },[startNode,finishNode])\r\n\r\n  useEffect(() => {\r\n    if(boardChange.clearBoard) {\r\n      CleanGrid()\r\n      HideHiddenWalls(0)\r\n    }\r\n    else if(boardChange.clearPath){\r\n      CleanGrid()\r\n      hasSolution.current = false\r\n    } \r\n    else if(boardChange.randomWalls){\r\n      CleanGrid()\r\n      HideHiddenWalls(30)\r\n    }\r\n  },[boardChange])\r\n\r\n  return (\r\n    <div className=\"grid-container\">\r\n      <div className='grid' style = {{\r\n        marginTop: `${tiltState ? '-314px' : '0px'}`,\r\n        transform: `${tiltState ? 'perspective(800px) rotateX(60deg)' : ''}`,\r\n        gridTemplateColumns: `repeat(${columns},auto)`\r\n      }}>\r\n        {grid.map( (_,idx) => {\r\n          return(\r\n            <div className={[\r\n              'node',\r\n              `${idx === startNode ? 'start' : ''}`,\r\n              `${idx === finishNode ? 'finish' : ''}`,\r\n              `${grid[idx] ? 'wall' : ''}`\r\n            ].join(\" \")} \r\n            key={idx}\r\n            onMouseDown = { () => HandleMouseDown(idx)}\r\n            onMouseEnter = { () => HandleMouseEnter(idx)} \r\n            style={{\r\n              width: `${nodeDimensions}px`,\r\n              height: `${nodeDimensions}px`, \r\n            }}>\r\n            </div> \r\n          )\r\n        })}\r\n      </div>\r\n    </div>\r\n  );\r\n}\r\nexport default Grid;","import React from 'react';\r\nimport './App.css';\r\nimport Header from './components/header/header';\r\nimport Grid from './components/grid/grid';\r\nimport { useDispatch } from 'react-redux';\r\nimport { changeAlgo } from './Reducers/algoSelect/algoSelectActions';\r\nimport { startSearch } from './Reducers/startSearch/startSearchActions'\r\nimport { gridTilt } from './Reducers/gridTilt/gridTiltActions'\r\nimport { searchSpeed } from './Reducers/searchSpeed/searchSpeedActions';\r\nimport { boardCommands, boardCommand } from './Reducers/boardChange/boardChangeAction'\r\n\r\nfunction App() {\r\n  \r\n  const dispatch = useDispatch()\r\n\r\n  const onAlgoChange = (algo:string) => {\r\n    dispatch(changeAlgo(algo))\r\n  }\r\n\r\n  const onStartSearch = (start:boolean) => {\r\n    dispatch(startSearch(start))\r\n  }\r\n\r\n  const onTiltChange = (tilt:boolean) => {\r\n    dispatch(gridTilt(tilt))\r\n  }\r\n\r\n  const onSearchSpeed = (speed:number) => {\r\n    dispatch(searchSpeed(speed))\r\n  }\r\n\r\n  const onBoardCommand = (state:boolean, action:boardCommands) => {\r\n    dispatch(boardCommand(state,action))\r\n  }\r\n\r\n  return (\r\n    <div className=\"App\">\r\n      <Header \r\n        changeAlgo={onAlgoChange} \r\n        startSearch={onStartSearch} \r\n        gridTilt={onTiltChange}\r\n        searchSpeed={onSearchSpeed}\r\n        boardCommand={onBoardCommand}\r\n        />\r\n      <Grid startSearch={onStartSearch}/>\r\n    </div>\r\n  );\r\n}\r\n\r\nexport default App;","export type startSearchAction = {\r\n    type: \"START_SEARCH\",\r\n    payload: boolean\r\n}\r\n\r\nexport const startSearch = (start:boolean):startSearchAction => ({\r\n    type: \"START_SEARCH\",\r\n    payload: start\r\n})","export type algoSelectAction = {\r\n    type: \"CHANGE_ALGORITHM\",\r\n    payload: string\r\n}\r\n\r\nexport const changeAlgo = (algo:string):algoSelectAction => ({\r\n    type: \"CHANGE_ALGORITHM\",\r\n    payload: algo\r\n})","export type gridTiltAction = {\r\n    type: \"CHANGE_TILT_STATE\",\r\n    payload: boolean\r\n}\r\n\r\nexport const gridTilt = (tilt:boolean):gridTiltAction => ({\r\n    type: 'CHANGE_TILT_STATE',\r\n    payload: tilt\r\n})","export type searchSpeedAction = {\r\n    type: \"CHANGE_SPEED\",\r\n    payload: number\r\n}\r\n\r\nexport const searchSpeed = (speed:number):searchSpeedAction => ({\r\n    type: 'CHANGE_SPEED',\r\n    payload: speed\r\n})","export type clearPathAction = {\r\n    type: \"CLEAR_PATH\",\r\n    payload: boolean\r\n}\r\n\r\nexport type clearBoardAction = {\r\n    type: \"CLEAR_BOARD\",\r\n    payload: boolean\r\n}\r\n\r\nexport type randomWallsAction = {\r\n    type: \"RANDOM_WALLS\",\r\n    payload: boolean\r\n}\r\n\r\nexport const boardCommand = (state:boolean, command:boardCommands):boardCommandDispatchTypes => ({\r\n    type: command,\r\n    payload: state\r\n})\r\n\r\nexport type boardCommands = \"CLEAR_PATH\" | \"CLEAR_BOARD\" | \"RANDOM_WALLS\"\r\n\r\nexport type boardCommandDispatchTypes = clearPathAction | clearBoardAction | randomWallsAction","import { boardCommandDispatchTypes, clearBoardAction, clearPathAction, randomWallsAction } from './boardChangeAction'\r\n\r\ninterface IDefaultState{\r\n    clearBoard: boolean,\r\n    clearPath: boolean,\r\n    randomWalls: boolean\r\n}\r\n\r\nconst initState:IDefaultState = {\r\n    clearBoard: false,\r\n    clearPath: false,\r\n    randomWalls: false\r\n}\r\n\r\nexport const boardChangeReducer = (state:IDefaultState = initState, action: boardCommandDispatchTypes ): IDefaultState => {\r\n    switch(action.type){\r\n        case 'CLEAR_BOARD':\r\n            return {\r\n                clearBoard: true,\r\n                clearPath: false,\r\n                randomWalls: false\r\n            }\r\n        case 'CLEAR_PATH':\r\n            return {\r\n                clearBoard: false,\r\n                clearPath: true,\r\n                randomWalls: false\r\n            }\r\n        case 'RANDOM_WALLS':\r\n            return {\r\n                clearBoard: false,\r\n                clearPath: false,\r\n                randomWalls: true\r\n            }\r\n        default:\r\n            return state\r\n    }\r\n}","import { createStore, combineReducers } from 'redux'\r\nimport { algoSelectReducer } from './Reducers/algoSelect/algoSelectReducer'\r\nimport { startSearchReducer } from './Reducers/startSearch/startSearchReducer'\r\nimport { tiltStateReducer } from './Reducers/gridTilt/gridTiltReducer'\r\nimport { searchSpeedReducer } from './Reducers/searchSpeed/searchSpeedReducer'\r\nimport { boardChangeReducer } from './Reducers/boardChange/boardChangeReducer'\r\n \r\nconst rootReducer = combineReducers({\r\n    algoSelect: algoSelectReducer,\r\n    startSearch: startSearchReducer,\r\n    tiltState: tiltStateReducer,\r\n    searchSpeed: searchSpeedReducer,\r\n    boardChange: boardChangeReducer\r\n    })\r\n\r\nexport type RootStore = ReturnType<typeof rootReducer>\r\n\r\nexport const store = createStore(rootReducer)","import { algoSelectAction } from './algoSelectActions'\r\n\r\nconst initialState = 'astar'\r\n\r\nexport const algoSelectReducer = (state:string = initialState, action:algoSelectAction) => {\r\n    switch(action.type){\r\n        case \"CHANGE_ALGORITHM\":{\r\n            return action.payload\r\n        }\r\n        default: \r\n            return state\r\n    }\r\n}","import { startSearchAction } from './startSearchActions'\r\n\r\nconst initialState = false\r\n\r\nexport const startSearchReducer = (state:boolean = initialState, action:startSearchAction) => {\r\n    switch(action.type){\r\n        case \"START_SEARCH\" :{\r\n            return action.payload\r\n        }\r\n        default: \r\n            return state\r\n    }\r\n}","import { gridTiltAction } from './gridTiltActions'\r\n\r\nconst initialState = true\r\n\r\nexport const tiltStateReducer = (state:boolean = initialState, action:gridTiltAction) => {\r\n    switch(action.type){\r\n        case 'CHANGE_TILT_STATE' :{\r\n            return action.payload\r\n        }\r\n        default: \r\n            return state\r\n    }\r\n}","import { searchSpeedAction } from './searchSpeedActions'\r\n\r\nconst initState = 10\r\n\r\nexport const searchSpeedReducer = (state:number = initState, action:searchSpeedAction) => {\r\n    switch(action.type){\r\n        case \"CHANGE_SPEED\":\r\n            return action.payload\r\n        default:\r\n            return state\r\n    }\r\n}","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport App from './App';\nimport { Provider } from 'react-redux'\nimport { store } from './store'\n \nReactDOM.render(\n  <Provider store={store}>\n    <App />\n  </Provider>,\n  document.getElementById('root')\n);\n"],"sourceRoot":""}