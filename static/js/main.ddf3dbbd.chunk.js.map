{"version":3,"sources":["algorithms/dijkstras/index.ts","algorithms/bestFirst/index.ts","Reducers/boardChange/boardChangeAction.ts","Reducers/startSearch/startSearchActions.ts","components/header/header.tsx","Reducers/algoSelect/algoSelectActions.ts","Reducers/gridTilt/gridTiltActions.ts","Reducers/searchSpeed/searchSpeedActions.ts","algorithms/astar/index.ts","algorithms/depthFirst/index.ts","algorithms/breadthFirst/index.ts","components/grid/grid.tsx","App.tsx","Reducers/boardChange/boardChangeReducer.ts","store.ts","Reducers/algoSelect/algoSelectReducer.ts","Reducers/startSearch/startSearchReducer.ts","Reducers/gridTilt/gridTiltReducer.ts","Reducers/searchSpeed/searchSpeedReducer.ts","index.tsx"],"names":["animationQueue","size","boardCommand","state","command","type","payload","startSearch","start","Header","dispatch","useDispatch","tilt","useSelector","tiltState","className","htmlFor","onChange","event","target","value","id","onClick","window","open","gridTilt","speed","searchSpeed","BuildNodeGrid","grid","buildNodeGrid","forEach","_","idx","isWall","gWeight","Infinity","hWeight","fWeight","parent","index","ManhattanDistance","p","q","width","pCol","pRow","Math","floor","qCol","qRow","abs","FindSmallestCost","array","smallestIndex","ListContains","nodeList","length","i","ListRemove","gridIndex","splice","CalcNodeCosts","nodeGrid","nodeIndex","closedNodes","openNodes","finish","UpdateWeightCost","parentIndex","push","tempNode","this","FindMinNode","sptSet","distance","FindNodeDistances","heap","Swap","index1","index2","temp","HeapInsert","item","Parent","current","fcost","HeapRemove","first","newHeap","slice","LeftChild","RightChild","HasLeftChild","HasRightChild","currentIndex","smallerIndex","Heapify","AddSurrondingNodes","visited","searchStack","searchQueue","Enqueue","node","Dequeue","shift","inQueue","Grid","useState","wallPercent","rows","random","GetBlankGrid","setGrid","columns","startNode","setStartNode","finishNode","setFinishNode","nodeDimensions","setNodeDimensions","prevFinish","useRef","wasWall","mouseStatus","startMoveStatus","finishMoveStatus","mouseIndex","hasSolution","algorithm","algoSelect","solving","boardChange","onmousedown","e","onmouseup","onresize","HideHiddenWalls","nodeWidth","innerWidth","useCallback","ne","document","getElementsByClassName","newGrid","location","getBoundingClientRect","x","y","innerHeight","CleanGrid","tempClassNames","j","classList","join","StartSearch","a","request","fetch","method","mode","headers","body","JSON","stringify","response","json","animations","setTimeout","StartSearchInstant","currentNode","reverseQueue","pop","console","log","AStarSearch","Array","fill","Dijkstra","BestFirstSearch","DepthFirstSearch","BreadthFirstSearch","useEffect","clearBoard","clearPath","randomWalls","style","marginTop","transform","gridTemplateColumns","map","key","onMouseDown","HandleMouseDown","onMouseEnter","HandleMouseEnter","height","App","initState","rootReducer","combineReducers","action","store","createStore","ReactDOM","render","getElementById"],"mappings":"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","file":"static/js/main.ddf3dbbd.chunk.js","sourcesContent":["import { Animation } from '../astar/index'\n\nexport interface Node{\n    isWall: boolean,\n    distance: number,\n    parent: number, \n    index: number\n}\n\nvar animationQueue: Animation[]\n\nexport const Dijkstra = (grid:boolean[],width:number,start:number,finish:number):Animation[] =>{\n    animationQueue = []\n    const sptSet:boolean[] =new Array(grid.length).fill(false)\n    const nodeGrid:Node[] = new Array(grid.length)\n    for(let i=0; i< nodeGrid.length; i++){\n        nodeGrid[i] = {\n            isWall: grid[i] ? true : false,\n            distance: Infinity,\n            parent: -1,\n            index: i\n        }\n        sptSet[i] = nodeGrid[i].isWall\n    }\n    nodeGrid[start] = {\n        ...nodeGrid[start],\n        distance:0,\n        parent:start\n    }\n    while(!sptSet[finish]){\n        var currentNode = nodeGrid[FindMinNode(nodeGrid,sptSet,finish)]\n        animationQueue.push({index: currentNode.index, className: ' searched'})\n        FindNodeDistances(nodeGrid,sptSet,currentNode.index,width)\n        sptSet[currentNode.index] = true\n    }\n\n    var parent = nodeGrid[finish].parent  \n    if(parent !== -1){\n        var reverseQueue:Animation[] = [] \n        while(parent !== nodeGrid[parent].parent){\n            reverseQueue.push({index: parent, className: ' shortestPath'})\n            parent = nodeGrid[parent].parent\n        }\n        while(reverseQueue.length > 0) animationQueue.push(reverseQueue.pop() as Animation)\n    }\n    else \n    {\n        console.log('No Path Found')\n    }\n    return animationQueue\n}\n\nexport const FindMinNode = (nodeGrid:Node[], sptSet:boolean[],finish:number):number => {\n    let smallestIndex = finish\n    nodeGrid.forEach( (_,idx) => {\n        if(nodeGrid[idx].distance < nodeGrid[smallestIndex].distance && !sptSet[idx]){\n            smallestIndex = idx\n        }\n    })\n    return smallestIndex\n}\n\nexport const FindNodeDistances = (nodeGrid:Node[], sptSet:boolean[],nodeIndex:number, width:number) => {\n    const UpdateWeightCost = (index:number, parentIndex:number) => {\n        if(!nodeGrid[index].isWall && !sptSet[index]){\n            nodeGrid[index] = {\n                ...nodeGrid[index],\n                distance: nodeGrid[parentIndex].distance + 1,\n                parent: parentIndex\n            }\n            animationQueue.push({\n                index:index,\n                className: ' openList'\n            })\n        }\n    }\n\n    //Top\n    if(nodeIndex >= width){\n        UpdateWeightCost(nodeIndex-width,nodeIndex)\n    }\n    //Right\n    if(nodeIndex % width !== width-1){\n       UpdateWeightCost(nodeIndex+1,nodeIndex)\n    }\n    //Bottom\n    if(nodeIndex < nodeGrid.length - width){\n       UpdateWeightCost(nodeIndex+width,nodeIndex)\n    }\n    //Left\n    if(nodeIndex % width !== 0){\n       UpdateWeightCost(nodeIndex-1,nodeIndex)\n    }\n}\n","import { Animation } from '../astar/index'\n\nvar animationQueue: Animation[] = []\nvar heap:Node[] = []\nvar size: number\n\ninterface Node {\n    isWall: boolean,\n    visited: boolean,\n    fcost: number,\n    parent: number, \n    index: number\n}\n\nexport const BestFirstSearch = (grid:boolean[],width:number,start:number,finish:number):Animation[] => {\n    animationQueue = []\n    heap = []\n    size = 0\n    const nodeGrid:Node[] = new Array(grid.length)\n    for(let i=0;i<grid.length;i++){\n        nodeGrid[i] = {\n            isWall: grid[i],\n            visited: false,\n            fcost: (i === start) ? ManhattanDistance(i,finish,width): Infinity,\n            parent: (i === start)? start : -1,\n            index: i\n        }\n    }\n\n    HeapInsert(nodeGrid[start])\n\n    while(heap.length > 0 && heap.length < width * 20){\n        const currentNode = HeapRemove()\n        nodeGrid[currentNode.index] = { \n            ...currentNode,\n            visited: true,\n        }\n        animationQueue.push({\n            index:currentNode.index,\n            className: ' searched'\n        })\n        if(currentNode.index === finish) break\n        else AddSurrondingNodes(nodeGrid,currentNode.index,width,finish)\n    }\n\n    var parent = nodeGrid[finish].parent  \n    if(parent !== -1){\n        var reverseQueue:Animation[] = [] \n        while(parent !== nodeGrid[parent].parent){\n            reverseQueue.push({index: parent, className: ' shortestPath'})\n            parent = nodeGrid[parent].parent\n        }\n        while(reverseQueue.length > 0) animationQueue.push(reverseQueue.pop() as Animation)\n    }\n    else \n    {\n        console.log('No Path Found')\n    }\n    return animationQueue\n}\n\nexport const Heapify = (index:number) => {\n    const LeftChild = (index: number):number => Math.floor(2*index+1) \n    const RightChild = (index: number):number => Math.floor(2*index+2)\n    const HasLeftChild = (index: number):boolean => LeftChild(index) < size\n    const HasRightChild = (index: number):boolean => RightChild(index) < size\n\n    var currentIndex = index\n    while(HasLeftChild(currentIndex)){    \n        var smallerIndex = LeftChild(currentIndex)\n        if(HasRightChild(currentIndex) && \n        heap[RightChild(currentIndex)].fcost < heap[LeftChild(currentIndex)].fcost){\n            smallerIndex = RightChild(currentIndex)\n        }\n        if(heap[currentIndex].fcost < heap[smallerIndex].fcost) break\n        else Swap(currentIndex, smallerIndex)\n        currentIndex = smallerIndex\n    }\n}\n\nexport const Swap = (index1:number, index2:number) => {\n    const temp = heap[index1]\n    heap[index1] = heap[index2]\n    heap[index2] = temp\n}\n\nexport const HeapInsert = (item:Node) => {\n    const Parent = (index: number):number => Math.floor((index - 1) / 2)\n    const HasParent = (index: number):boolean => Parent(index) >= 0\n    heap[size] = item\n    size++\n    var current = size - 1 \n    while(HasParent(current) && (heap[current].fcost < heap[Parent(current)].fcost)){\n        Swap(current,Parent(current))\n        current = Parent(current)\n    }\n}\n\nexport const HeapRemove = ():Node => {\n    const first = heap[0]\n    heap[0] = heap[size - 1]\n    const newHeap = heap.slice(0,size-1)\n    heap = [...newHeap]\n    size--\n    Heapify(0)\n    return first\n}\n\nexport const ManhattanDistance = (p:number, q:number, width: number):number => {\n    const pRow = Math.floor(p/width)\n    var pCol\n    if(p >= width) pCol = p % width\n    else pCol = p\n    const qRow = Math.floor(q/width)\n    var qCol\n    if(q >= width) qCol = q % width\n    else qCol = q\n    return Math.floor((Math.abs(qRow - pRow) + Math.abs(qCol - pCol))*10)  \n}\n\nexport const AddSurrondingNodes = (nodeGrid:Node[],nodeIndex:number, width:number,finish:number) => {\n    const UpdateWeightCost = (index:number, parentIndex:number) => {\n        if(!nodeGrid[index].isWall && !nodeGrid[index].visited && nodeGrid[index].fcost === Infinity){\n            nodeGrid[index] = {\n                ...nodeGrid[index],\n                fcost: ManhattanDistance(index,finish,width),\n                parent: parentIndex\n            }\n            animationQueue.push({\n                index:index,\n                className: ' openList'\n            })\n            HeapInsert(nodeGrid[index])\n        }\n    }\n\n    //Top\n    if(nodeIndex >= width){\n        UpdateWeightCost(nodeIndex-width,nodeIndex)\n    }\n    //Right\n    if(nodeIndex % width !== width-1){\n       UpdateWeightCost(nodeIndex+1,nodeIndex)\n    }\n    //Bottom\n    if(nodeIndex < nodeGrid.length - width){\n       UpdateWeightCost(nodeIndex+width,nodeIndex)\n    }\n    //Left\n    if(nodeIndex % width !== 0){\n       UpdateWeightCost(nodeIndex-1,nodeIndex)\n    }\n}","export type clearPathAction = {\n    type: \"CLEAR_PATH\",\n    payload: boolean\n}\n\nexport type clearBoardAction = {\n    type: \"CLEAR_BOARD\",\n    payload: boolean\n}\n\nexport type randomWallsAction = {\n    type: \"RANDOM_WALLS\",\n    payload: boolean\n}\n\nexport const boardCommand = (state:boolean, command:boardCommands):boardCommandDispatchTypes => ({\n    type: command,\n    payload: state\n})\n\nexport type boardCommands = \"CLEAR_PATH\" | \"CLEAR_BOARD\" | \"RANDOM_WALLS\"\n\nexport type boardCommandDispatchTypes = clearPathAction | clearBoardAction | randomWallsAction","export type startSearchAction = {\n    type: \"START_SEARCH\",\n    payload: boolean\n}\n\nexport const startSearch = (start:boolean):startSearchAction => ({\n    type: \"START_SEARCH\",\n    payload: start\n})","import React, { ChangeEvent } from \"react\";\nimport \"./header.css\";\nimport { useSelector, useDispatch } from \"react-redux\";\nimport { RootStore } from \"../../store\";\nimport { boardCommand } from \"../../Reducers/boardChange/boardChangeAction\";\nimport { changeAlgo } from \"../../Reducers/algoSelect/algoSelectActions\";\nimport { startSearch } from \"../../Reducers/startSearch/startSearchActions\";\nimport { gridTilt } from \"../../Reducers/gridTilt/gridTiltActions\";\nimport { searchSpeed } from \"../../Reducers/searchSpeed/searchSpeedActions\";\n\nconst Header = () => {\n  const dispatch = useDispatch();\n\n  const tilt = useSelector((state: RootStore) => state.tiltState);\n\n  const onAlgoChange = (event: ChangeEvent<HTMLSelectElement>) =>\n    dispatch(changeAlgo(event.target.value));\n\n  const onStartSearch = () => dispatch(startSearch(true));\n\n  const onGridTilt = () => dispatch(gridTilt(tilt ? false : true));\n\n  const onSearchSpeed = (event: ChangeEvent<HTMLSelectElement>) => {\n    const speed = event.target.value;\n    var speedValue;\n    if (speed === \"SLOW\") speedValue = 100;\n    else if (speed === \"MEDIUM\") speedValue = 50;\n    else speedValue = 10;\n    dispatch(searchSpeed(speedValue));\n  };\n\n  const HandleGitHubClick = () =>\n    window.open(\"https://github.com/JCrews253/path-finding-visualizer\");\n\n  const HandleHomeClick = () =>\n    window.open(\"https://jamesrcrews.com\", \"_self\");\n\n  return (\n    <div className=\"header\">\n      <h1 className=\"title\">Retro 80's Path Finding Visualization</h1>\n      <div className=\"label-element-container\">\n        <label className=\"algo-select-label\" htmlFor=\"algo-select\">\n          Choose an Algorithm:\n        </label>\n        <select onChange={onAlgoChange} id=\"algo-select\">\n          <option value=\"astar\">A* Search</option>\n          <option value=\"dijkstra\">Dijkstra's Algorithm</option>\n          <option value=\"best-first\">Best First Search</option>\n          <option value=\"depth-first\">Depth First Search</option>\n          <option value=\"breadth-first\">Breadth First Search</option>\n        </select>\n      </div>\n      <div className=\"buttons-container\">\n        <button className=\"animated-button\" onClick={HandleHomeClick}>\n          Home\n        </button>\n        <button className=\"animated-button\" onClick={HandleGitHubClick}>\n          Github\n        </button>\n        <hr />\n        <button className=\"animated-button\" onClick={onStartSearch}>\n          Start\n        </button>\n        <button\n          className=\"animated-button\"\n          onClick={() => dispatch(boardCommand(true, \"CLEAR_PATH\"))}\n        >\n          Clear Path\n        </button>\n        <button\n          className=\"animated-button\"\n          onClick={() => dispatch(boardCommand(true, \"CLEAR_BOARD\"))}\n        >\n          Clear Board\n        </button>\n        <button\n          className=\"animated-button\"\n          onClick={() => dispatch(boardCommand(true, \"RANDOM_WALLS\"))}\n        >\n          Random Walls\n        </button>\n        <button className=\"animated-button\" onClick={onGridTilt}>\n          Toggle Tilt\n        </button>\n      </div>\n      <div className=\"label-element-container\">\n        <label className=\"speed-select-label\" htmlFor=\"speed-select\">\n          Choose Search Speed\n        </label>\n        <select onChange={onSearchSpeed} id=\"speed-select\">\n          <option value=\"FAST\">Fast</option>\n          <option value=\"MEDIUM\">Medium</option>\n          <option value=\"SLOW\">Slow</option>\n        </select>\n      </div>\n    </div>\n  );\n};\n\nexport default Header;\n","export type algoSelectAction = {\n    type: \"CHANGE_ALGORITHM\",\n    payload: string\n}\n\nexport const changeAlgo = (algo:string):algoSelectAction => ({\n    type: \"CHANGE_ALGORITHM\",\n    payload: algo\n})","export type gridTiltAction = {\n    type: \"CHANGE_TILT_STATE\",\n    payload: boolean\n}\n\nexport const gridTilt = (tilt:boolean):gridTiltAction => ({\n    type: 'CHANGE_TILT_STATE',\n    payload: tilt\n})","export type searchSpeedAction = {\n    type: \"CHANGE_SPEED\",\n    payload: number\n}\n\nexport const searchSpeed = (speed:number):searchSpeedAction => ({\n    type: 'CHANGE_SPEED',\n    payload: speed\n})","import '../../App.css'\n\nexport interface Node{\n    isWall: boolean,\n    gWeight: number,\n    hWeight: number,\n    fWeight: number,\n    parent: number, \n    index: number\n}\n\nexport interface Animation{\n    index: number,\n    className: string\n}\n\nvar animationQueue: Animation[] = []\n\nexport const AStarSearch = (grid: boolean[], width: number, start:number, finish: number):Animation[] => {\n    animationQueue = []\n    const openNodes: Node[] = []\n    const closedNodes:Node[] = []\n    const nodeGrid = [...BuildNodeGrid(grid)]\n\n    nodeGrid[start] = {\n        ...nodeGrid[start],\n        gWeight: 0,\n        hWeight: 0,\n        fWeight: 0,\n        parent: start\n    } \n    openNodes.push(nodeGrid[start])\n\n    while(openNodes.length > 0){\n        var currentNode = nodeGrid[FindSmallestCost(openNodes)]\n        if(currentNode.index !== start && currentNode.index !== finish) animationQueue.push({index: currentNode.index, className: ' searched'})\n        ListRemove(openNodes,currentNode.index)\n        closedNodes.push(currentNode)\n        if(currentNode.index === finish) break;\n        CalcNodeCosts(nodeGrid, currentNode.index, closedNodes, openNodes, start, finish, width)\n    }\n\n    var parent = nodeGrid[finish].parent\n    \n    if(parent !== -1){\n        var reverseQueue:Animation[] = [] \n        while(parent !== nodeGrid[parent].parent){\n            reverseQueue.push({index: parent, className: ' shortestPath'})\n            parent = nodeGrid[parent].parent\n        }\n        while(reverseQueue.length > 0) animationQueue.push(reverseQueue.pop() as Animation)\n    }\n    else \n    {\n        console.log('No Path Found')\n    }\n\n    return animationQueue\n}\n\nexport const BuildNodeGrid = (grid: boolean[]):Node[] => {\n    const buildNodeGrid:Node[] = []\n    grid.forEach( (_,idx) => {\n        buildNodeGrid[idx] = {\n            isWall: grid[idx],\n            gWeight: Infinity,\n            hWeight: Infinity,\n            fWeight: Infinity,\n            parent: -1,\n            index: idx,\n        }\n    })\n   return buildNodeGrid\n}\n\nexport const ManhattanDistance = (p:number, q:number, width: number):number => {\n    const pRow = Math.floor(p/width)\n    var pCol\n    if(p >= width) pCol = p % width\n    else pCol = p\n    const qRow = Math.floor(q/width)\n    var qCol\n    if(q >= width) qCol = q % width\n    else qCol = q\n    return Math.floor((Math.abs(qRow - pRow) + Math.abs(qCol - pCol))*10)  \n}\n\nexport const FindSmallestCost = (array:Node[]):number => {\n    let smallestIndex = 0\n    array.forEach( (_,idx) => {\n        if(array[idx].fWeight < array[smallestIndex].fWeight){\n            smallestIndex = idx\n        }\n        else if (array[idx].fWeight === array[smallestIndex].fWeight && array[idx].hWeight < array[smallestIndex].hWeight){\n            smallestIndex = idx\n        }\n    })\n    return array[smallestIndex].index\n}\n\nexport const ListContains = (nodeList: Node[], index:number):boolean => {\n    if(nodeList.length === 0 ) return false\n    for(let i = 0; i < nodeList.length; i++ ){\n        if(nodeList[i].index === index) return true\n    }\n    return false\n}\n\nexport const ListRemove = (nodeList: Node[], gridIndex:number) => {\n    for(let i = 0; i < nodeList.length; i++){\n        if(nodeList[i].index === gridIndex){\n            nodeList.splice(i,1)\n            break\n        }\n    }\n}\n\nexport const CalcNodeCosts = (nodeGrid:Node[], nodeIndex:number, closedNodes:Node[],openNodes:Node[],start:number,finish:number, width:number) => {\n    const UpdateWeightCost = (index:number,parentIndex:number) => {\n        if(!nodeGrid[index].isWall && !ListContains(closedNodes,index)){\n            if(index !== finish){\n                animationQueue.push({\n                    index:index,\n                    className: ' openList'\n                })\n            }\n            const tempNode:Node = { ...nodeGrid[index],\n                gWeight: nodeGrid[parentIndex].gWeight + ManhattanDistance(index,parentIndex,width),\n                hWeight: ManhattanDistance(index, finish, width),\n                get fWeight (){\n                    return this.gWeight + this.hWeight\n                },\n                parent: parentIndex\n            }\n            if(tempNode.fWeight < nodeGrid[index].fWeight || !ListContains(openNodes,index)){\n                nodeGrid[index] = tempNode\n                openNodes.push(nodeGrid[index])\n            }\n            else if( tempNode.fWeight === nodeGrid[index].fWeight && tempNode.hWeight < nodeGrid[index].hWeight){\n                nodeGrid[index] = tempNode\n                openNodes.push(nodeGrid[index])\n            }\n        }\n    }\n    //Top\n    if(nodeIndex >= width) UpdateWeightCost(nodeIndex-width,nodeIndex)\n    //Right\n    if(nodeIndex % width !== width-1) UpdateWeightCost(nodeIndex+1,nodeIndex)\n    //Bottom\n    if(nodeIndex < nodeGrid.length - width) UpdateWeightCost(nodeIndex+width,nodeIndex)\n    //Left\n    if(nodeIndex % width !== 0) UpdateWeightCost(nodeIndex-1,nodeIndex)\n}\n","import { Animation } from '../astar/index'\n\ninterface Node{\n    isWall:boolean,\n    visited:boolean,\n    parent:number,\n    index:number\n}\n\nvar animationQueue: Animation[] = []\nvar searchStack: Node[] = []\n\nexport const DepthFirstSearch = (grid:boolean[],width:number,start:number,finish:number):Animation[] => {\n    animationQueue = []\n    searchStack = []\n    const nodeGrid: Node[] = []\n    for(let i = 0;i<grid.length;i++){\n        nodeGrid[i] = {\n            isWall: grid[i],\n            visited: false,\n            parent: (i === start) ? start : -1,\n            index: i\n        }\n    }\n    \n    searchStack.push(nodeGrid[start])\n\n    while(searchStack.length > 0){\n        const currentNode = searchStack.pop() as Node\n        nodeGrid[currentNode.index] = {\n            ...currentNode,\n            visited: true\n        }\n        animationQueue.push({\n            index:currentNode.index,\n            className: ' searched'\n        })\n        if(currentNode.index === finish) break\n        else AddSurrondingNodes(nodeGrid,currentNode.index,width)\n    }\n\n    var parent = nodeGrid[finish].parent  \n    if(parent !== -1){\n        var reverseQueue:Animation[] = [] \n        while(parent !== nodeGrid[parent].parent){\n            reverseQueue.push({index: parent, className: ' shortestPath'})\n            parent = nodeGrid[parent].parent\n        }\n        while(reverseQueue.length > 0) animationQueue.push(reverseQueue.pop() as Animation)\n    }\n    else \n    {\n        console.log('No Path Found')\n    }\n    return animationQueue\n}\n\nexport const AddSurrondingNodes = (nodeGrid:Node[],nodeIndex:number, width:number) => {\n    const UpdateWeightCost = (index:number, parentIndex:number) => {\n        if(!nodeGrid[index].isWall && !nodeGrid[index].visited){\n            nodeGrid[index] = {\n                ...nodeGrid[index],\n                parent: parentIndex\n            }\n            animationQueue.push({\n                index:index,\n                className: ' openList'\n            })\n            searchStack.push(nodeGrid[index])\n        }\n    }\n\n    //Top\n    if(nodeIndex >= width){\n        UpdateWeightCost(nodeIndex-width,nodeIndex)\n    }\n    //Right\n    if(nodeIndex % width !== width-1){\n       UpdateWeightCost(nodeIndex+1,nodeIndex)\n    }\n    //Bottom\n    if(nodeIndex < nodeGrid.length - width){\n       UpdateWeightCost(nodeIndex+width,nodeIndex)\n    }\n    //Left\n    if(nodeIndex % width !== 0){\n       UpdateWeightCost(nodeIndex-1,nodeIndex)\n    }\n}","import { Animation } from '../astar/index'\n\ninterface Node{\n    isWall:boolean,\n    visited:boolean,\n    inQueue: boolean,\n    parent: number,\n    index: number,\n}\n\nvar animationQueue: Animation[] = []\nvar searchQueue:Node[] = []\n\nexport const BreadthFirstSearch = (grid:boolean[],width:number,start:number,finish:number):Animation[] => {\n    animationQueue = []\n    searchQueue = []\n    const nodeGrid:Node[] = []\n    for(let i=0;i<grid.length;i++){\n        nodeGrid[i] = {\n            isWall: grid[i],\n            visited: false,\n            inQueue: i === start,\n            parent: (i === start) ? start : -1,\n            index: i\n        }\n    }\n\n    Enqueue(nodeGrid[start])\n\n    while(searchQueue.length > 0){\n        console.log(searchQueue.length)\n        const currentNode = Dequeue()\n        nodeGrid[currentNode.index] ={\n            ...currentNode,\n            visited: true\n        }\n        animationQueue.push({\n            index:currentNode.index,\n            className: ' searched'\n        })\n        if(currentNode.index === finish) break\n        else AddSurrondingNodes(nodeGrid,currentNode.index,width)\n    }\n\n    var parent = nodeGrid[finish].parent  \n    if(parent !== -1){\n        var reverseQueue:Animation[] = [] \n        while(parent !== nodeGrid[parent].parent){\n            reverseQueue.push({index: parent, className: ' shortestPath'})\n            parent = nodeGrid[parent].parent\n        }\n        while(reverseQueue.length > 0) animationQueue.push(reverseQueue.pop() as Animation)\n    }\n    else \n    {\n        console.log('No Path Found')\n    }\n    return animationQueue\n}\n\nconst Enqueue = (node:Node) => searchQueue.push(node)\n\nconst Dequeue = ():Node => searchQueue.shift() as Node\n\nexport const AddSurrondingNodes = (nodeGrid:Node[],nodeIndex:number, width:number) => {\n    const UpdateWeightCost = (index:number, parentIndex:number) => {\n        if(!nodeGrid[index].isWall && !nodeGrid[index].visited && !nodeGrid[index].inQueue){\n            nodeGrid[index] = {\n                ...nodeGrid[index],\n                inQueue: true,\n                parent: parentIndex\n            }\n            animationQueue.push({\n                index:index,\n                className: ' openList'\n            })\n            Enqueue(nodeGrid[index])\n        }\n    }\n    //Top\n    if(nodeIndex >= width){\n        UpdateWeightCost(nodeIndex-width,nodeIndex)\n    }\n    //Right\n    if(nodeIndex % width !== width-1){\n       UpdateWeightCost(nodeIndex+1,nodeIndex)\n    }\n    //Bottom\n    if(nodeIndex < nodeGrid.length - width){\n       UpdateWeightCost(nodeIndex+width,nodeIndex)\n    }\n    //Left\n    if(nodeIndex % width !== 0){\n       UpdateWeightCost(nodeIndex-1,nodeIndex)\n    }\n}","import React, { useState, useRef, useEffect, useCallback } from \"react\";\nimport { AStarSearch, Animation } from \"../../algorithms/astar\";\nimport \"./grid.css\";\nimport { useSelector, useDispatch } from \"react-redux\";\nimport { RootStore } from \"../../store\";\nimport { Dijkstra } from \"../../algorithms/dijkstras\";\nimport { BestFirstSearch } from \"../../algorithms/bestFirst\";\nimport { DepthFirstSearch } from \"../../algorithms/depthFirst\";\nimport { BreadthFirstSearch } from \"../../algorithms/breadthFirst\";\nimport { startSearch } from \"../../Reducers/startSearch/startSearchActions\";\n\nconst rows = 18;\nconst columns = 63;\n\nconst Grid = () => {\n  const GetBlankGrid = (wallPercent: number): boolean[] => {\n    let array: boolean[] = [];\n    for (let i = 0; i < rows * columns; i++) {\n      array[i] = Math.random() >= 1 - wallPercent / 100;\n    }\n    return array;\n  };\n\n  const [grid, setGrid] = useState(() => GetBlankGrid(0));\n  const [startNode, setStartNode] = useState(\n    rows * columns - 1 - Math.floor(columns / 2)\n  );\n  const [finishNode, setFinishNode] = useState(Math.floor(columns / 2));\n  const [nodeDimensions, setNodeDimensions] = useState(50);\n  const prevFinish = useRef({ index: finishNode, wasWall: false });\n  const dispatch = useDispatch();\n\n  const mouseStatus = useRef(false);\n  const startMoveStatus = useRef(false);\n  const finishMoveStatus = useRef(false);\n  const mouseIndex = useRef(-1);\n  const hasSolution = useRef(false);\n  const algorithm = useSelector((state: RootStore) => state.algoSelect);\n  const solving = useSelector((state: RootStore) => state.startSearch);\n  const tiltState = useSelector((state: RootStore) => state.tiltState);\n  const speed = useSelector((state: RootStore) => state.searchSpeed);\n  const boardChange = useSelector((state: RootStore) => state.boardChange);\n\n  window.onmousedown = (e: MouseEvent) => {\n    if (e.type === \"mousedown\") mouseStatus.current = true;\n  };\n\n  window.onmouseup = (e: MouseEvent) => {\n    if (e.type === \"mouseup\") {\n      mouseStatus.current = false;\n      startMoveStatus.current = false;\n      finishMoveStatus.current = false;\n    }\n  };\n  window.onresize = () => {\n    if (tiltState) {\n      HideHiddenWalls(20);\n    } else {\n      const nodeWidth = (window.innerWidth - 200) / columns;\n      setNodeDimensions(nodeWidth);\n    }\n  };\n  const HideHiddenWalls = useCallback(\n    (wallPercent: number) => {\n      const ne = document.getElementsByClassName(\n        \"node\"\n      ) as HTMLCollectionOf<HTMLElement>;\n      const newGrid = [...grid];\n      for (let i = 0; i < ne.length; i++) {\n        const location = ne[i].getBoundingClientRect();\n        if (\n          location.x + location.width / 2 < 0 ||\n          location.x > window.innerWidth - 50 ||\n          location.y > window.innerHeight\n        ) {\n          newGrid[i] = true;\n        } else {\n          newGrid[i] = Math.random() >= 1 - wallPercent / 100;\n        }\n      }\n      setGrid(newGrid);\n    },\n    [grid]\n  );\n\n  const HandleMouseDown = (index: number) => {\n    if (!solving) {\n      if (index === startNode) startMoveStatus.current = true;\n      else if (index === finishNode) finishMoveStatus.current = true;\n      else {\n        mouseIndex.current = index;\n        const newGrid = [...grid];\n        newGrid[index] = grid[index] ? false : true;\n        setGrid(newGrid);\n      }\n    }\n  };\n\n  const HandleMouseEnter = (index: number) => {\n    if (!solving) {\n      if (startMoveStatus.current) setStartNode(index);\n      else if (finishMoveStatus.current) {\n        const newGrid = [...grid];\n        newGrid[prevFinish.current.index] = prevFinish.current.wasWall;\n        newGrid[index] = false;\n        setGrid(newGrid);\n        prevFinish.current = {\n          index: index,\n          wasWall: grid[index],\n        };\n        setFinishNode(index);\n      } else if (mouseStatus.current && index !== mouseIndex.current) {\n        mouseIndex.current = index;\n        const newGrid = [...grid];\n        newGrid[index] = grid[index] ? false : true;\n        setGrid(newGrid);\n      }\n    }\n  };\n\n  const CleanGrid = () => {\n    const ne = document.getElementsByClassName(\n      \"node\"\n    ) as HTMLCollectionOf<HTMLElement>;\n    for (let i = 0; i < ne.length; i++) {\n      const tempClassNames = [];\n      for (let j = 0; j < ne[i].classList.length; j++) {\n        if (ne[i].classList[j] === \"node\") tempClassNames.push(\"node\");\n        if (ne[i].classList[j] === \"start\") tempClassNames.push(\"start\");\n        if (ne[i].classList[j] === \"finish\") tempClassNames.push(\"finish\");\n        if (ne[i].classList[j] === \"wall\") tempClassNames.push(\"wall\");\n      }\n      ne[i].className = tempClassNames.join(\" \");\n    }\n  };\n  const StartSearch = useCallback(async () => {\n    dispatch(startSearch(true));\n    CleanGrid();\n    grid[finishNode] = false;\n    const request = {\n      algorithm: algorithm,\n      grid: grid,\n      width: columns,\n      start: startNode,\n      finish: finishNode,\n    };\n\n    const response = await fetch(\n      `https://path-finding-visualizer.herokuapp.com/solutions`,\n      {\n        method: \"POST\", // *GET, POST, PUT, DELETE, etc.\n        mode: \"cors\", // no-cors, *cors, same-origin\n        headers: {\n          \"Content-Type\": \"application/json\",\n          \"Access-Control-Allow-Origin\": \"*\",\n          \"Access-Control-Allow-Headers\": \"*\",\n        },\n        body: JSON.stringify(request), // body data type must match \"Content-Type\" header\n      }\n    );\n    const animations = await response.json();\n\n    const ne = document.getElementsByClassName(\n      \"node\"\n    ) as HTMLCollectionOf<HTMLElement>;\n    if (animations.length === 0) dispatch(startSearch(false));\n    for (let i = 0; i < animations.length; i++) {\n      setTimeout(() => {\n        ne[animations[i].index].className += animations[i].className;\n        if (i === animations.length - 1) dispatch(startSearch(false));\n      }, i * speed);\n    }\n    hasSolution.current = true;\n  }, [algorithm, dispatch, finishNode, grid, speed, startNode]);\n\n  const StartSearchInstant = useCallback(() => {\n    var animations: Animation[] = [];\n    if (algorithm === \"astar\")\n      animations = AStarSearch(grid, columns, startNode, finishNode);\n    if (algorithm === \"dijkstra\")\n      animations = Dijkstra(grid, columns, startNode, finishNode);\n    if (algorithm === \"best-first\")\n      animations = BestFirstSearch(grid, columns, startNode, finishNode);\n    if (algorithm === \"depth-first\")\n      animations = DepthFirstSearch(grid, columns, startNode, finishNode);\n    if (algorithm === \"breadth-first\")\n      animations = BreadthFirstSearch(grid, columns, startNode, finishNode);\n    const ne = document.getElementsByClassName(\n      \"node\"\n    ) as HTMLCollectionOf<HTMLElement>;\n    for (let i = 0; i < animations.length; i++) {\n      ne[animations[i].index].className += animations[i].className + \"Instant\";\n    }\n  }, [algorithm, finishNode, grid, startNode]);\n\n  useEffect(() => {\n    if (tiltState) {\n      setNodeDimensions(50);\n      setStartNode(rows * columns - 1 - Math.floor(columns / 2));\n      setFinishNode(Math.floor(columns / 2));\n    } else {\n      const nodeWidth = (window.innerWidth - 200) / columns;\n      setNodeDimensions(nodeWidth);\n    }\n  }, [tiltState]);\n\n  useEffect(() => {\n    if (solving) StartSearch();\n  }, [solving, StartSearch]);\n\n  useEffect(() => {\n    if (hasSolution.current) {\n      CleanGrid();\n      StartSearchInstant();\n    }\n  }, [startNode, finishNode, StartSearchInstant]);\n\n  useEffect(() => {\n    if (boardChange.clearBoard) {\n      CleanGrid();\n      HideHiddenWalls(0);\n    } else if (boardChange.clearPath) {\n      CleanGrid();\n      hasSolution.current = false;\n    } else if (boardChange.randomWalls) {\n      CleanGrid();\n      HideHiddenWalls(30);\n    }\n  }, [boardChange, HideHiddenWalls]);\n\n  return (\n    <div className=\"grid-container\">\n      <div\n        className=\"grid\"\n        style={{\n          marginTop: `${tiltState ? \"-314px\" : \"0px\"}`,\n          transform: `${tiltState ? \"perspective(800px) rotateX(60deg)\" : \"\"}`,\n          gridTemplateColumns: `repeat(${columns},auto)`,\n        }}\n      >\n        {grid.map((_, idx) => {\n          return (\n            <div\n              className={[\n                \"node\",\n                `${idx === startNode ? \"start\" : \"\"}`,\n                `${idx === finishNode ? \"finish\" : \"\"}`,\n                `${grid[idx] ? \"wall\" : \"\"}`,\n              ].join(\" \")}\n              key={idx}\n              onMouseDown={() => HandleMouseDown(idx)}\n              onMouseEnter={() => HandleMouseEnter(idx)}\n              style={{\n                width: `${nodeDimensions}px`,\n                height: `${nodeDimensions}px`,\n              }}\n            ></div>\n          );\n        })}\n      </div>\n    </div>\n  );\n};\nexport default Grid;\n","import React from 'react';\nimport './App.css';\nimport Header from './components/header/header';\nimport Grid from './components/grid/grid';\n\nfunction App() {\n\n  return (\n    <div className=\"App\">\n      <Header/>\n      <Grid/>\n    </div>\n  );\n}\n\nexport default App;","import { boardCommandDispatchTypes } from './boardChangeAction'\n\ninterface IDefaultState{\n    clearBoard: boolean,\n    clearPath: boolean,\n    randomWalls: boolean\n}\n\nconst initState:IDefaultState = {\n    clearBoard: false,\n    clearPath: false,\n    randomWalls: false\n}\n\nexport const boardChangeReducer = (state:IDefaultState = initState, action: boardCommandDispatchTypes ): IDefaultState => {\n    switch(action.type){\n        case 'CLEAR_BOARD':\n            return {\n                clearBoard: true,\n                clearPath: false,\n                randomWalls: false\n            }\n        case 'CLEAR_PATH':\n            return {\n                clearBoard: false,\n                clearPath: true,\n                randomWalls: false\n            }\n        case 'RANDOM_WALLS':\n            return {\n                clearBoard: false,\n                clearPath: false,\n                randomWalls: true\n            }\n        default:\n            return state\n    }\n}\n","import { createStore, combineReducers } from 'redux'\nimport { algoSelectReducer } from './Reducers/algoSelect/algoSelectReducer'\nimport { startSearchReducer } from './Reducers/startSearch/startSearchReducer'\nimport { tiltStateReducer } from './Reducers/gridTilt/gridTiltReducer'\nimport { searchSpeedReducer } from './Reducers/searchSpeed/searchSpeedReducer'\nimport { boardChangeReducer } from './Reducers/boardChange/boardChangeReducer'\n \nconst rootReducer = combineReducers({\n    algoSelect: algoSelectReducer,\n    startSearch: startSearchReducer,\n    tiltState: tiltStateReducer,\n    searchSpeed: searchSpeedReducer,\n    boardChange: boardChangeReducer\n    })\n\nexport type RootStore = ReturnType<typeof rootReducer>\n\nexport const store = createStore(rootReducer)","import { algoSelectAction } from './algoSelectActions'\n\nconst initialState = 'astar'\n\nexport const algoSelectReducer = (state:string = initialState, action:algoSelectAction) => {\n    switch(action.type){\n        case \"CHANGE_ALGORITHM\":{\n            return action.payload\n        }\n        default: \n            return state\n    }\n}","import { startSearchAction } from './startSearchActions'\n\nconst initialState = false\n\nexport const startSearchReducer = (state:boolean = initialState, action:startSearchAction) => {\n    switch(action.type){\n        case \"START_SEARCH\" :{\n            return action.payload\n        }\n        default: \n            return state\n    }\n}","import { gridTiltAction } from './gridTiltActions'\n\nconst initialState = true\n\nexport const tiltStateReducer = (state:boolean = initialState, action:gridTiltAction) => {\n    switch(action.type){\n        case 'CHANGE_TILT_STATE' :{\n            return action.payload\n        }\n        default: \n            return state\n    }\n}","import { searchSpeedAction } from './searchSpeedActions'\n\nconst initState = 10\n\nexport const searchSpeedReducer = (state:number = initState, action:searchSpeedAction) => {\n    switch(action.type){\n        case \"CHANGE_SPEED\":\n            return action.payload\n        default:\n            return state\n    }\n}","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport App from './App';\nimport { Provider } from 'react-redux'\nimport { store } from './store'\n \nReactDOM.render(\n  <Provider store={store}>\n    <App />\n  </Provider>,\n  document.getElementById('root')\n);\n"],"sourceRoot":""}