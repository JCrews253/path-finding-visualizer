{"version":3,"sources":["algorithms/dijkstras/index.ts","algorithms/bestFirst/index.ts","Reducers/boardChange/boardChangeAction.ts","Reducers/startSearch/startSearchActions.ts","components/header/header.tsx","Reducers/algoSelect/algoSelectActions.ts","Reducers/gridTilt/gridTiltActions.ts","Reducers/searchSpeed/searchSpeedActions.ts","algorithms/astar/index.ts","algorithms/depthFirst/index.ts","algorithms/breadthFirst/index.ts","components/grid/grid.tsx","App.tsx","Reducers/boardChange/boardChangeReducer.ts","store.ts","Reducers/algoSelect/algoSelectReducer.ts","Reducers/startSearch/startSearchReducer.ts","Reducers/gridTilt/gridTiltReducer.ts","Reducers/searchSpeed/searchSpeedReducer.ts","index.tsx"],"names":["animationQueue","size","boardCommand","state","command","type","payload","startSearch","start","Header","dispatch","useDispatch","tilt","useSelector","tiltState","className","htmlFor","onChange","event","target","value","id","onClick","window","open","gridTilt","speed","searchSpeed","BuildNodeGrid","grid","buildNodeGrid","forEach","_","idx","isWall","gWeight","Infinity","hWeight","fWeight","parent","index","ManhattanDistance","p","q","width","pCol","pRow","Math","floor","qCol","qRow","abs","FindSmallestCost","array","smallestIndex","ListContains","nodeList","length","i","ListRemove","gridIndex","splice","CalcNodeCosts","nodeGrid","nodeIndex","closedNodes","openNodes","finish","UpdateWeightCost","parentIndex","push","tempNode","this","FindMinNode","sptSet","distance","FindNodeDistances","heap","Swap","index1","index2","temp","HeapInsert","item","Parent","current","fcost","HeapRemove","first","newHeap","slice","LeftChild","RightChild","HasLeftChild","HasRightChild","currentIndex","smallerIndex","Heapify","AddSurrondingNodes","visited","searchStack","searchQueue","Enqueue","node","Dequeue","shift","inQueue","Grid","onmousedown","e","mouseStatus","onmouseup","startMoveStatus","finishMoveStatus","onresize","HideHiddenWalls","nodeWidth","innerWidth","setNodeDimensions","wallPercent","ne","document","getElementsByClassName","newGrid","location","getBoundingClientRect","x","y","innerHeight","random","setGrid","CleanGrid","tempClassNames","j","classList","join","StartSearch","a","finishNode","request","algorithm","startNode","fetch","method","mode","headers","body","JSON","stringify","response","json","animations","setTimeout","hasSolution","StartSearchInstant","currentNode","reverseQueue","pop","console","log","AStarSearch","Array","fill","Dijkstra","BestFirstSearch","DepthFirstSearch","BreadthFirstSearch","useState","rows","GetBlankGrid","columns","setStartNode","setFinishNode","nodeDimensions","prevFinish","useRef","wasWall","mouseIndex","algoSelect","solving","boardChange","useEffect","clearBoard","clearPath","randomWalls","style","marginTop","transform","gridTemplateColumns","map","key","onMouseDown","HandleMouseDown","onMouseEnter","HandleMouseEnter","height","App","initState","rootReducer","combineReducers","action","store","createStore","ReactDOM","render","getElementById"],"mappings":"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","file":"static/js/main.0fdd484c.chunk.js","sourcesContent":["import { Animation } from '../astar/index'\r\n\r\nexport interface Node{\r\n    isWall: boolean,\r\n    distance: number,\r\n    parent: number, \r\n    index: number\r\n}\r\n\r\nvar animationQueue: Animation[]\r\n\r\nexport const Dijkstra = (grid:boolean[],width:number,start:number,finish:number):Animation[] =>{\r\n    animationQueue = []\r\n    const sptSet:boolean[] =new Array(grid.length).fill(false)\r\n    const nodeGrid:Node[] = new Array(grid.length)\r\n    for(let i=0; i< nodeGrid.length; i++){\r\n        nodeGrid[i] = {\r\n            isWall: grid[i] ? true : false,\r\n            distance: Infinity,\r\n            parent: -1,\r\n            index: i\r\n        }\r\n        sptSet[i] = nodeGrid[i].isWall\r\n    }\r\n    nodeGrid[start] = {\r\n        ...nodeGrid[start],\r\n        distance:0,\r\n        parent:start\r\n    }\r\n    while(!sptSet[finish]){\r\n        var currentNode = nodeGrid[FindMinNode(nodeGrid,sptSet,finish)]\r\n        animationQueue.push({index: currentNode.index, className: ' searched'})\r\n        FindNodeDistances(nodeGrid,sptSet,currentNode.index,width)\r\n        sptSet[currentNode.index] = true\r\n    }\r\n\r\n    var parent = nodeGrid[finish].parent  \r\n    if(parent !== -1){\r\n        var reverseQueue:Animation[] = [] \r\n        while(parent !== nodeGrid[parent].parent){\r\n            reverseQueue.push({index: parent, className: ' shortestPath'})\r\n            parent = nodeGrid[parent].parent\r\n        }\r\n        while(reverseQueue.length > 0) animationQueue.push(reverseQueue.pop() as Animation)\r\n    }\r\n    else \r\n    {\r\n        console.log('No Path Found')\r\n    }\r\n    return animationQueue\r\n}\r\n\r\nexport const FindMinNode = (nodeGrid:Node[], sptSet:boolean[],finish:number):number => {\r\n    let smallestIndex = finish\r\n    nodeGrid.forEach( (_,idx) => {\r\n        if(nodeGrid[idx].distance < nodeGrid[smallestIndex].distance && !sptSet[idx]){\r\n            smallestIndex = idx\r\n        }\r\n    })\r\n    return smallestIndex\r\n}\r\n\r\nexport const FindNodeDistances = (nodeGrid:Node[], sptSet:boolean[],nodeIndex:number, width:number) => {\r\n    const UpdateWeightCost = (index:number, parentIndex:number) => {\r\n        if(!nodeGrid[index].isWall && !sptSet[index]){\r\n            nodeGrid[index] = {\r\n                ...nodeGrid[index],\r\n                distance: nodeGrid[parentIndex].distance + 1,\r\n                parent: parentIndex\r\n            }\r\n            animationQueue.push({\r\n                index:index,\r\n                className: ' openList'\r\n            })\r\n        }\r\n    }\r\n\r\n    //Top\r\n    if(nodeIndex >= width){\r\n        UpdateWeightCost(nodeIndex-width,nodeIndex)\r\n    }\r\n    //Right\r\n    if(nodeIndex % width !== width-1){\r\n       UpdateWeightCost(nodeIndex+1,nodeIndex)\r\n    }\r\n    //Bottom\r\n    if(nodeIndex < nodeGrid.length - width){\r\n       UpdateWeightCost(nodeIndex+width,nodeIndex)\r\n    }\r\n    //Left\r\n    if(nodeIndex % width !== 0){\r\n       UpdateWeightCost(nodeIndex-1,nodeIndex)\r\n    }\r\n}\r\n","import { Animation } from '../astar/index'\r\n\r\nvar animationQueue: Animation[] = []\r\nvar heap:Node[] = []\r\nvar size: number\r\n\r\ninterface Node {\r\n    isWall: boolean,\r\n    visited: boolean,\r\n    fcost: number,\r\n    parent: number, \r\n    index: number\r\n}\r\n\r\nexport const BestFirstSearch = (grid:boolean[],width:number,start:number,finish:number):Animation[] => {\r\n    animationQueue = []\r\n    heap = []\r\n    size = 0\r\n    const nodeGrid:Node[] = new Array(grid.length)\r\n    for(let i=0;i<grid.length;i++){\r\n        nodeGrid[i] = {\r\n            isWall: grid[i],\r\n            visited: false,\r\n            fcost: (i === start) ? ManhattanDistance(i,finish,width): Infinity,\r\n            parent: (i === start)? start : -1,\r\n            index: i\r\n        }\r\n    }\r\n\r\n    HeapInsert(nodeGrid[start])\r\n\r\n    while(heap.length > 0 && heap.length < width * 20){\r\n        const currentNode = HeapRemove()\r\n        nodeGrid[currentNode.index] = { \r\n            ...currentNode,\r\n            visited: true,\r\n        }\r\n        animationQueue.push({\r\n            index:currentNode.index,\r\n            className: ' searched'\r\n        })\r\n        if(currentNode.index === finish) break\r\n        else AddSurrondingNodes(nodeGrid,currentNode.index,width,finish)\r\n    }\r\n\r\n    var parent = nodeGrid[finish].parent  \r\n    if(parent !== -1){\r\n        var reverseQueue:Animation[] = [] \r\n        while(parent !== nodeGrid[parent].parent){\r\n            reverseQueue.push({index: parent, className: ' shortestPath'})\r\n            parent = nodeGrid[parent].parent\r\n        }\r\n        while(reverseQueue.length > 0) animationQueue.push(reverseQueue.pop() as Animation)\r\n    }\r\n    else \r\n    {\r\n        console.log('No Path Found')\r\n    }\r\n    return animationQueue\r\n}\r\n\r\nexport const Heapify = (index:number) => {\r\n    const LeftChild = (index: number):number => Math.floor(2*index+1) \r\n    const RightChild = (index: number):number => Math.floor(2*index+2)\r\n    const HasLeftChild = (index: number):boolean => LeftChild(index) < size\r\n    const HasRightChild = (index: number):boolean => RightChild(index) < size\r\n\r\n    var currentIndex = index\r\n    while(HasLeftChild(currentIndex)){    \r\n        var smallerIndex = LeftChild(currentIndex)\r\n        if(HasRightChild(currentIndex) && \r\n        heap[RightChild(currentIndex)].fcost < heap[LeftChild(currentIndex)].fcost){\r\n            smallerIndex = RightChild(currentIndex)\r\n        }\r\n        if(heap[currentIndex].fcost < heap[smallerIndex].fcost) break\r\n        else Swap(currentIndex, smallerIndex)\r\n        currentIndex = smallerIndex\r\n    }\r\n}\r\n\r\nexport const Swap = (index1:number, index2:number) => {\r\n    const temp = heap[index1]\r\n    heap[index1] = heap[index2]\r\n    heap[index2] = temp\r\n}\r\n\r\nexport const HeapInsert = (item:Node) => {\r\n    const Parent = (index: number):number => Math.floor((index - 1) / 2)\r\n    const HasParent = (index: number):boolean => Parent(index) >= 0\r\n    heap[size] = item\r\n    size++\r\n    var current = size - 1 \r\n    while(HasParent(current) && (heap[current].fcost < heap[Parent(current)].fcost)){\r\n        Swap(current,Parent(current))\r\n        current = Parent(current)\r\n    }\r\n}\r\n\r\nexport const HeapRemove = ():Node => {\r\n    const first = heap[0]\r\n    heap[0] = heap[size - 1]\r\n    const newHeap = heap.slice(0,size-1)\r\n    heap = [...newHeap]\r\n    size--\r\n    Heapify(0)\r\n    return first\r\n}\r\n\r\nexport const ManhattanDistance = (p:number, q:number, width: number):number => {\r\n    const pRow = Math.floor(p/width)\r\n    var pCol\r\n    if(p >= width) pCol = p % width\r\n    else pCol = p\r\n    const qRow = Math.floor(q/width)\r\n    var qCol\r\n    if(q >= width) qCol = q % width\r\n    else qCol = q\r\n    return Math.floor((Math.abs(qRow - pRow) + Math.abs(qCol - pCol))*10)  \r\n}\r\n\r\nexport const AddSurrondingNodes = (nodeGrid:Node[],nodeIndex:number, width:number,finish:number) => {\r\n    const UpdateWeightCost = (index:number, parentIndex:number) => {\r\n        if(!nodeGrid[index].isWall && !nodeGrid[index].visited && nodeGrid[index].fcost === Infinity){\r\n            nodeGrid[index] = {\r\n                ...nodeGrid[index],\r\n                fcost: ManhattanDistance(index,finish,width),\r\n                parent: parentIndex\r\n            }\r\n            animationQueue.push({\r\n                index:index,\r\n                className: ' openList'\r\n            })\r\n            HeapInsert(nodeGrid[index])\r\n        }\r\n    }\r\n\r\n    //Top\r\n    if(nodeIndex >= width){\r\n        UpdateWeightCost(nodeIndex-width,nodeIndex)\r\n    }\r\n    //Right\r\n    if(nodeIndex % width !== width-1){\r\n       UpdateWeightCost(nodeIndex+1,nodeIndex)\r\n    }\r\n    //Bottom\r\n    if(nodeIndex < nodeGrid.length - width){\r\n       UpdateWeightCost(nodeIndex+width,nodeIndex)\r\n    }\r\n    //Left\r\n    if(nodeIndex % width !== 0){\r\n       UpdateWeightCost(nodeIndex-1,nodeIndex)\r\n    }\r\n}","export type clearPathAction = {\r\n    type: \"CLEAR_PATH\",\r\n    payload: boolean\r\n}\r\n\r\nexport type clearBoardAction = {\r\n    type: \"CLEAR_BOARD\",\r\n    payload: boolean\r\n}\r\n\r\nexport type randomWallsAction = {\r\n    type: \"RANDOM_WALLS\",\r\n    payload: boolean\r\n}\r\n\r\nexport const boardCommand = (state:boolean, command:boardCommands):boardCommandDispatchTypes => ({\r\n    type: command,\r\n    payload: state\r\n})\r\n\r\nexport type boardCommands = \"CLEAR_PATH\" | \"CLEAR_BOARD\" | \"RANDOM_WALLS\"\r\n\r\nexport type boardCommandDispatchTypes = clearPathAction | clearBoardAction | randomWallsAction","export type startSearchAction = {\r\n    type: \"START_SEARCH\",\r\n    payload: boolean\r\n}\r\n\r\nexport const startSearch = (start:boolean):startSearchAction => ({\r\n    type: \"START_SEARCH\",\r\n    payload: start\r\n})","import React, { ChangeEvent } from \"react\";\r\nimport \"./header.css\";\r\nimport { useSelector, useDispatch } from \"react-redux\";\r\nimport { RootStore } from \"../../store\";\r\nimport { boardCommand } from \"../../Reducers/boardChange/boardChangeAction\";\r\nimport { changeAlgo } from \"../../Reducers/algoSelect/algoSelectActions\";\r\nimport { startSearch } from \"../../Reducers/startSearch/startSearchActions\";\r\nimport { gridTilt } from \"../../Reducers/gridTilt/gridTiltActions\";\r\nimport { searchSpeed } from \"../../Reducers/searchSpeed/searchSpeedActions\";\r\n\r\nconst Header = () => {\r\n  const dispatch = useDispatch();\r\n\r\n  const tilt = useSelector((state: RootStore) => state.tiltState);\r\n\r\n  const onAlgoChange = (event: ChangeEvent<HTMLSelectElement>) =>\r\n    dispatch(changeAlgo(event.target.value));\r\n\r\n  const onStartSearch = () => dispatch(startSearch(true));\r\n\r\n  const onGridTilt = () => dispatch(gridTilt(tilt ? false : true));\r\n\r\n  const onSearchSpeed = (event: ChangeEvent<HTMLSelectElement>) => {\r\n    const speed = event.target.value;\r\n    var speedValue;\r\n    if (speed === \"SLOW\") speedValue = 100;\r\n    else if (speed === \"MEDIUM\") speedValue = 50;\r\n    else speedValue = 10;\r\n    dispatch(searchSpeed(speedValue));\r\n  };\r\n\r\n  const HandleGitHubClick = () =>\r\n    window.open(\"https://github.com/JCrews253/path-finding-visualizer\");\r\n\r\n  const HandleHomeClick = () => window.open(\"https://jamesrcrews.com\", \"_self\");\r\n\r\n  return (\r\n    <div className=\"header\">\r\n      <h1 className=\"title\">Retro 80's Path Finding Visualization</h1>\r\n      <div className=\"label-element-container\">\r\n        <label className=\"algo-select-label\" htmlFor=\"algo-select\">\r\n          Choose an Algorithm:\r\n        </label>\r\n        <select onChange={onAlgoChange} id=\"algo-select\">\r\n          <option value=\"astar\">A* Search</option>\r\n          <option value=\"dijkstra\">Dijkstra's Algorithm</option>\r\n          <option value=\"best-first\">Best First Search</option>\r\n          <option value=\"depth-first\">Depth First Search</option>\r\n          <option value=\"breadth-first\">Breadth First Search</option>\r\n        </select>\r\n      </div>\r\n      <div className=\"buttons-container\">\r\n        <button className=\"animated-button\" onClick={HandleHomeClick}>\r\n          Home\r\n        </button>\r\n        <button className=\"animated-button\" onClick={HandleGitHubClick}>\r\n          Github\r\n        </button>\r\n        <hr />\r\n        <button className=\"animated-button\" onClick={onStartSearch}>\r\n          Start\r\n        </button>\r\n        <button\r\n          className=\"animated-button\"\r\n          onClick={() => dispatch(boardCommand(true, \"CLEAR_PATH\"))}\r\n        >\r\n          Clear Path\r\n        </button>\r\n        <button\r\n          className=\"animated-button\"\r\n          onClick={() => dispatch(boardCommand(true, \"CLEAR_BOARD\"))}\r\n        >\r\n          Clear Board\r\n        </button>\r\n        <button\r\n          className=\"animated-button\"\r\n          onClick={() => dispatch(boardCommand(true, \"RANDOM_WALLS\"))}\r\n        >\r\n          Random Walls\r\n        </button>\r\n        <button className=\"animated-button\" onClick={onGridTilt}>\r\n          Toggle Tilt\r\n        </button>\r\n      </div>\r\n      <div className=\"label-element-container\">\r\n        <label className=\"speed-select-label\" htmlFor=\"speed-select\">\r\n          Choose Search Speed\r\n        </label>\r\n        <select onChange={onSearchSpeed} id=\"speed-select\">\r\n          <option value=\"FAST\">Fast</option>\r\n          <option value=\"MEDIUM\">Medium</option>\r\n          <option value=\"SLOW\">Slow</option>\r\n        </select>\r\n      </div>\r\n    </div>\r\n  );\r\n};\r\n\r\nexport default Header;\r\n","export type algoSelectAction = {\r\n    type: \"CHANGE_ALGORITHM\",\r\n    payload: string\r\n}\r\n\r\nexport const changeAlgo = (algo:string):algoSelectAction => ({\r\n    type: \"CHANGE_ALGORITHM\",\r\n    payload: algo\r\n})","export type gridTiltAction = {\r\n    type: \"CHANGE_TILT_STATE\",\r\n    payload: boolean\r\n}\r\n\r\nexport const gridTilt = (tilt:boolean):gridTiltAction => ({\r\n    type: 'CHANGE_TILT_STATE',\r\n    payload: tilt\r\n})","export type searchSpeedAction = {\r\n    type: \"CHANGE_SPEED\",\r\n    payload: number\r\n}\r\n\r\nexport const searchSpeed = (speed:number):searchSpeedAction => ({\r\n    type: 'CHANGE_SPEED',\r\n    payload: speed\r\n})","import '../../App.css'\r\n\r\nexport interface Node{\r\n    isWall: boolean,\r\n    gWeight: number,\r\n    hWeight: number,\r\n    fWeight: number,\r\n    parent: number, \r\n    index: number\r\n}\r\n\r\nexport interface Animation{\r\n    index: number,\r\n    className: string\r\n}\r\n\r\nvar animationQueue: Animation[] = []\r\n\r\nexport const AStarSearch = (grid: boolean[], width: number, start:number, finish: number):Animation[] => {\r\n    animationQueue = []\r\n    const openNodes: Node[] = []\r\n    const closedNodes:Node[] = []\r\n    const nodeGrid = [...BuildNodeGrid(grid)]\r\n\r\n    nodeGrid[start] = {\r\n        ...nodeGrid[start],\r\n        gWeight: 0,\r\n        hWeight: 0,\r\n        fWeight: 0,\r\n        parent: start\r\n    } \r\n    openNodes.push(nodeGrid[start])\r\n\r\n    while(openNodes.length > 0){\r\n        var currentNode = nodeGrid[FindSmallestCost(openNodes)]\r\n        if(currentNode.index !== start && currentNode.index !== finish) animationQueue.push({index: currentNode.index, className: ' searched'})\r\n        ListRemove(openNodes,currentNode.index)\r\n        closedNodes.push(currentNode)\r\n        if(currentNode.index === finish) break;\r\n        CalcNodeCosts(nodeGrid, currentNode.index, closedNodes, openNodes, start, finish, width)\r\n    }\r\n\r\n    var parent = nodeGrid[finish].parent\r\n    \r\n    if(parent !== -1){\r\n        var reverseQueue:Animation[] = [] \r\n        while(parent !== nodeGrid[parent].parent){\r\n            reverseQueue.push({index: parent, className: ' shortestPath'})\r\n            parent = nodeGrid[parent].parent\r\n        }\r\n        while(reverseQueue.length > 0) animationQueue.push(reverseQueue.pop() as Animation)\r\n    }\r\n    else \r\n    {\r\n        console.log('No Path Found')\r\n    }\r\n\r\n    return animationQueue\r\n}\r\n\r\nexport const BuildNodeGrid = (grid: boolean[]):Node[] => {\r\n    const buildNodeGrid:Node[] = []\r\n    grid.forEach( (_,idx) => {\r\n        buildNodeGrid[idx] = {\r\n            isWall: grid[idx],\r\n            gWeight: Infinity,\r\n            hWeight: Infinity,\r\n            fWeight: Infinity,\r\n            parent: -1,\r\n            index: idx,\r\n        }\r\n    })\r\n   return buildNodeGrid\r\n}\r\n\r\nexport const ManhattanDistance = (p:number, q:number, width: number):number => {\r\n    const pRow = Math.floor(p/width)\r\n    var pCol\r\n    if(p >= width) pCol = p % width\r\n    else pCol = p\r\n    const qRow = Math.floor(q/width)\r\n    var qCol\r\n    if(q >= width) qCol = q % width\r\n    else qCol = q\r\n    return Math.floor((Math.abs(qRow - pRow) + Math.abs(qCol - pCol))*10)  \r\n}\r\n\r\nexport const FindSmallestCost = (array:Node[]):number => {\r\n    let smallestIndex = 0\r\n    array.forEach( (_,idx) => {\r\n        if(array[idx].fWeight < array[smallestIndex].fWeight){\r\n            smallestIndex = idx\r\n        }\r\n        else if (array[idx].fWeight === array[smallestIndex].fWeight && array[idx].hWeight < array[smallestIndex].hWeight){\r\n            smallestIndex = idx\r\n        }\r\n    })\r\n    return array[smallestIndex].index\r\n}\r\n\r\nexport const ListContains = (nodeList: Node[], index:number):boolean => {\r\n    if(nodeList.length === 0 ) return false\r\n    for(let i = 0; i < nodeList.length; i++ ){\r\n        if(nodeList[i].index === index) return true\r\n    }\r\n    return false\r\n}\r\n\r\nexport const ListRemove = (nodeList: Node[], gridIndex:number) => {\r\n    for(let i = 0; i < nodeList.length; i++){\r\n        if(nodeList[i].index === gridIndex){\r\n            nodeList.splice(i,1)\r\n            break\r\n        }\r\n    }\r\n}\r\n\r\nexport const CalcNodeCosts = (nodeGrid:Node[], nodeIndex:number, closedNodes:Node[],openNodes:Node[],start:number,finish:number, width:number) => {\r\n    const UpdateWeightCost = (index:number,parentIndex:number) => {\r\n        if(!nodeGrid[index].isWall && !ListContains(closedNodes,index)){\r\n            if(index !== finish){\r\n                animationQueue.push({\r\n                    index:index,\r\n                    className: ' openList'\r\n                })\r\n            }\r\n            const tempNode:Node = { ...nodeGrid[index],\r\n                gWeight: nodeGrid[parentIndex].gWeight + ManhattanDistance(index,parentIndex,width),\r\n                hWeight: ManhattanDistance(index, finish, width),\r\n                get fWeight (){\r\n                    return this.gWeight + this.hWeight\r\n                },\r\n                parent: parentIndex\r\n            }\r\n            if(tempNode.fWeight < nodeGrid[index].fWeight || !ListContains(openNodes,index)){\r\n                nodeGrid[index] = tempNode\r\n                openNodes.push(nodeGrid[index])\r\n            }\r\n            else if( tempNode.fWeight === nodeGrid[index].fWeight && tempNode.hWeight < nodeGrid[index].hWeight){\r\n                nodeGrid[index] = tempNode\r\n                openNodes.push(nodeGrid[index])\r\n            }\r\n        }\r\n    }\r\n    //Top\r\n    if(nodeIndex >= width) UpdateWeightCost(nodeIndex-width,nodeIndex)\r\n    //Right\r\n    if(nodeIndex % width !== width-1) UpdateWeightCost(nodeIndex+1,nodeIndex)\r\n    //Bottom\r\n    if(nodeIndex < nodeGrid.length - width) UpdateWeightCost(nodeIndex+width,nodeIndex)\r\n    //Left\r\n    if(nodeIndex % width !== 0) UpdateWeightCost(nodeIndex-1,nodeIndex)\r\n}\r\n","import { Animation } from '../astar/index'\r\n\r\ninterface Node{\r\n    isWall:boolean,\r\n    visited:boolean,\r\n    parent:number,\r\n    index:number\r\n}\r\n\r\nvar animationQueue: Animation[] = []\r\nvar searchStack: Node[] = []\r\n\r\nexport const DepthFirstSearch = (grid:boolean[],width:number,start:number,finish:number):Animation[] => {\r\n    animationQueue = []\r\n    searchStack = []\r\n    const nodeGrid: Node[] = []\r\n    for(let i = 0;i<grid.length;i++){\r\n        nodeGrid[i] = {\r\n            isWall: grid[i],\r\n            visited: false,\r\n            parent: (i === start) ? start : -1,\r\n            index: i\r\n        }\r\n    }\r\n    \r\n    searchStack.push(nodeGrid[start])\r\n\r\n    while(searchStack.length > 0){\r\n        const currentNode = searchStack.pop() as Node\r\n        nodeGrid[currentNode.index] = {\r\n            ...currentNode,\r\n            visited: true\r\n        }\r\n        animationQueue.push({\r\n            index:currentNode.index,\r\n            className: ' searched'\r\n        })\r\n        if(currentNode.index === finish) break\r\n        else AddSurrondingNodes(nodeGrid,currentNode.index,width)\r\n    }\r\n\r\n    var parent = nodeGrid[finish].parent  \r\n    if(parent !== -1){\r\n        var reverseQueue:Animation[] = [] \r\n        while(parent !== nodeGrid[parent].parent){\r\n            reverseQueue.push({index: parent, className: ' shortestPath'})\r\n            parent = nodeGrid[parent].parent\r\n        }\r\n        while(reverseQueue.length > 0) animationQueue.push(reverseQueue.pop() as Animation)\r\n    }\r\n    else \r\n    {\r\n        console.log('No Path Found')\r\n    }\r\n    return animationQueue\r\n}\r\n\r\nexport const AddSurrondingNodes = (nodeGrid:Node[],nodeIndex:number, width:number) => {\r\n    const UpdateWeightCost = (index:number, parentIndex:number) => {\r\n        if(!nodeGrid[index].isWall && !nodeGrid[index].visited){\r\n            nodeGrid[index] = {\r\n                ...nodeGrid[index],\r\n                parent: parentIndex\r\n            }\r\n            animationQueue.push({\r\n                index:index,\r\n                className: ' openList'\r\n            })\r\n            searchStack.push(nodeGrid[index])\r\n        }\r\n    }\r\n\r\n    //Top\r\n    if(nodeIndex >= width){\r\n        UpdateWeightCost(nodeIndex-width,nodeIndex)\r\n    }\r\n    //Right\r\n    if(nodeIndex % width !== width-1){\r\n       UpdateWeightCost(nodeIndex+1,nodeIndex)\r\n    }\r\n    //Bottom\r\n    if(nodeIndex < nodeGrid.length - width){\r\n       UpdateWeightCost(nodeIndex+width,nodeIndex)\r\n    }\r\n    //Left\r\n    if(nodeIndex % width !== 0){\r\n       UpdateWeightCost(nodeIndex-1,nodeIndex)\r\n    }\r\n}","import { Animation } from '../astar/index'\r\n\r\ninterface Node{\r\n    isWall:boolean,\r\n    visited:boolean,\r\n    inQueue: boolean,\r\n    parent: number,\r\n    index: number,\r\n}\r\n\r\nvar animationQueue: Animation[] = []\r\nvar searchQueue:Node[] = []\r\n\r\nexport const BreadthFirstSearch = (grid:boolean[],width:number,start:number,finish:number):Animation[] => {\r\n    animationQueue = []\r\n    searchQueue = []\r\n    const nodeGrid:Node[] = []\r\n    for(let i=0;i<grid.length;i++){\r\n        nodeGrid[i] = {\r\n            isWall: grid[i],\r\n            visited: false,\r\n            inQueue: i === start,\r\n            parent: (i === start) ? start : -1,\r\n            index: i\r\n        }\r\n    }\r\n\r\n    Enqueue(nodeGrid[start])\r\n\r\n    while(searchQueue.length > 0){\r\n        console.log(searchQueue.length)\r\n        const currentNode = Dequeue()\r\n        nodeGrid[currentNode.index] ={\r\n            ...currentNode,\r\n            visited: true\r\n        }\r\n        animationQueue.push({\r\n            index:currentNode.index,\r\n            className: ' searched'\r\n        })\r\n        if(currentNode.index === finish) break\r\n        else AddSurrondingNodes(nodeGrid,currentNode.index,width)\r\n    }\r\n\r\n    var parent = nodeGrid[finish].parent  \r\n    if(parent !== -1){\r\n        var reverseQueue:Animation[] = [] \r\n        while(parent !== nodeGrid[parent].parent){\r\n            reverseQueue.push({index: parent, className: ' shortestPath'})\r\n            parent = nodeGrid[parent].parent\r\n        }\r\n        while(reverseQueue.length > 0) animationQueue.push(reverseQueue.pop() as Animation)\r\n    }\r\n    else \r\n    {\r\n        console.log('No Path Found')\r\n    }\r\n    return animationQueue\r\n}\r\n\r\nconst Enqueue = (node:Node) => searchQueue.push(node)\r\n\r\nconst Dequeue = ():Node => searchQueue.shift() as Node\r\n\r\nexport const AddSurrondingNodes = (nodeGrid:Node[],nodeIndex:number, width:number) => {\r\n    const UpdateWeightCost = (index:number, parentIndex:number) => {\r\n        if(!nodeGrid[index].isWall && !nodeGrid[index].visited && !nodeGrid[index].inQueue){\r\n            nodeGrid[index] = {\r\n                ...nodeGrid[index],\r\n                inQueue: true,\r\n                parent: parentIndex\r\n            }\r\n            animationQueue.push({\r\n                index:index,\r\n                className: ' openList'\r\n            })\r\n            Enqueue(nodeGrid[index])\r\n        }\r\n    }\r\n    //Top\r\n    if(nodeIndex >= width){\r\n        UpdateWeightCost(nodeIndex-width,nodeIndex)\r\n    }\r\n    //Right\r\n    if(nodeIndex % width !== width-1){\r\n       UpdateWeightCost(nodeIndex+1,nodeIndex)\r\n    }\r\n    //Bottom\r\n    if(nodeIndex < nodeGrid.length - width){\r\n       UpdateWeightCost(nodeIndex+width,nodeIndex)\r\n    }\r\n    //Left\r\n    if(nodeIndex % width !== 0){\r\n       UpdateWeightCost(nodeIndex-1,nodeIndex)\r\n    }\r\n}","import React, { useState, useRef, useEffect } from \"react\";\r\nimport { AStarSearch, Animation } from \"../../algorithms/astar\";\r\nimport \"./grid.css\";\r\nimport { useSelector, useDispatch } from \"react-redux\";\r\nimport { RootStore } from \"../../store\";\r\nimport { Dijkstra } from \"../../algorithms/dijkstras\";\r\nimport { BestFirstSearch } from \"../../algorithms/bestFirst\";\r\nimport { DepthFirstSearch } from \"../../algorithms/depthFirst\";\r\nimport { BreadthFirstSearch } from \"../../algorithms/breadthFirst\";\r\nimport { startSearch } from \"../../Reducers/startSearch/startSearchActions\";\r\n\r\nconst rows = 18;\r\nconst columns = 63;\r\n\r\nconst Grid = () => {\r\n  window.onmousedown = (e: MouseEvent) => {\r\n    if (e.type === \"mousedown\") mouseStatus.current = true;\r\n  };\r\n\r\n  window.onmouseup = (e: MouseEvent) => {\r\n    if (e.type === \"mouseup\") {\r\n      mouseStatus.current = false;\r\n      startMoveStatus.current = false;\r\n      finishMoveStatus.current = false;\r\n    }\r\n  };\r\n  window.onresize = () => {\r\n    if (tiltState) {\r\n      HideHiddenWalls(20);\r\n    } else {\r\n      const nodeWidth = (window.innerWidth - 200) / columns;\r\n      setNodeDimensions(nodeWidth);\r\n    }\r\n  };\r\n  const HideHiddenWalls = (wallPercent: number) => {\r\n    const ne = document.getElementsByClassName(\r\n      \"node\"\r\n    ) as HTMLCollectionOf<HTMLElement>;\r\n    const newGrid = [...grid];\r\n    for (let i = 0; i < ne.length; i++) {\r\n      const location = ne[i].getBoundingClientRect();\r\n      if (\r\n        location.x + location.width / 2 < 0 ||\r\n        location.x > window.innerWidth - 50 ||\r\n        location.y > window.innerHeight\r\n      ) {\r\n        newGrid[i] = true;\r\n      } else {\r\n        newGrid[i] = Math.random() >= 1 - wallPercent / 100;\r\n      }\r\n    }\r\n    setGrid(newGrid);\r\n  };\r\n\r\n  const HandleMouseDown = (index: number) => {\r\n    if (!solving) {\r\n      if (index === startNode) startMoveStatus.current = true;\r\n      else if (index === finishNode) finishMoveStatus.current = true;\r\n      else {\r\n        mouseIndex.current = index;\r\n        const newGrid = [...grid];\r\n        newGrid[index] = grid[index] ? false : true;\r\n        setGrid(newGrid);\r\n      }\r\n    }\r\n  };\r\n\r\n  const HandleMouseEnter = (index: number) => {\r\n    if (!solving) {\r\n      if (startMoveStatus.current) setStartNode(index);\r\n      else if (finishMoveStatus.current) {\r\n        const newGrid = [...grid];\r\n        newGrid[prevFinish.current.index] = prevFinish.current.wasWall;\r\n        newGrid[index] = false;\r\n        setGrid(newGrid);\r\n        prevFinish.current = {\r\n          index: index,\r\n          wasWall: grid[index],\r\n        };\r\n        setFinishNode(index);\r\n      } else if (mouseStatus.current && index !== mouseIndex.current) {\r\n        mouseIndex.current = index;\r\n        const newGrid = [...grid];\r\n        newGrid[index] = grid[index] ? false : true;\r\n        setGrid(newGrid);\r\n      }\r\n    }\r\n  };\r\n\r\n  const GetBlankGrid = (wallPercent: number): boolean[] => {\r\n    let array: boolean[] = [];\r\n    for (let i = 0; i < rows * columns; i++) {\r\n      array[i] = Math.random() >= 1 - wallPercent / 100;\r\n    }\r\n    return array;\r\n  };\r\n  const CleanGrid = () => {\r\n    const ne = document.getElementsByClassName(\r\n      \"node\"\r\n    ) as HTMLCollectionOf<HTMLElement>;\r\n    for (let i = 0; i < ne.length; i++) {\r\n      const tempClassNames = [];\r\n      for (let j = 0; j < ne[i].classList.length; j++) {\r\n        if (ne[i].classList[j] === \"node\") tempClassNames.push(\"node\");\r\n        if (ne[i].classList[j] === \"start\") tempClassNames.push(\"start\");\r\n        if (ne[i].classList[j] === \"finish\") tempClassNames.push(\"finish\");\r\n        if (ne[i].classList[j] === \"wall\") tempClassNames.push(\"wall\");\r\n      }\r\n      ne[i].className = tempClassNames.join(\" \");\r\n    }\r\n  };\r\n  const StartSearch = async () => {\r\n    dispatch(startSearch(true));\r\n    CleanGrid();\r\n    grid[finishNode] = false;\r\n    const request = {\r\n      algorithm: algorithm,\r\n      grid: grid,\r\n      width: columns,\r\n      start: startNode,\r\n      finish: finishNode,\r\n    };\r\n\r\n    const response = await fetch(\r\n      `https://path-finding-visualizer.herokuapp.com/solutions`,\r\n      {\r\n        method: \"POST\", // *GET, POST, PUT, DELETE, etc.\r\n        mode: \"cors\", // no-cors, *cors, same-origin\r\n        headers: {\r\n          \"Content-Type\": \"application/json\",\r\n          \"Access-Control-Allow-Origin\": \"*\",\r\n          \"Access-Control-Allow-Headers\": \"*\",\r\n        },\r\n        body: JSON.stringify(request), // body data type must match \"Content-Type\" header\r\n      }\r\n    );\r\n    const animations = await response.json();\r\n\r\n    const ne = document.getElementsByClassName(\r\n      \"node\"\r\n    ) as HTMLCollectionOf<HTMLElement>;\r\n    if (animations.length === 0) dispatch(startSearch(false));\r\n    for (let i = 0; i < animations.length; i++) {\r\n      setTimeout(() => {\r\n        ne[animations[i].index].className += animations[i].className;\r\n        if (i === animations.length - 1) dispatch(startSearch(false));\r\n      }, i * speed);\r\n    }\r\n    hasSolution.current = true;\r\n  };\r\n  const StartSearchInstant = () => {\r\n    var animations: Animation[] = [];\r\n    if (algorithm === \"astar\")\r\n      animations = AStarSearch(grid, columns, startNode, finishNode);\r\n    if (algorithm === \"dijkstra\")\r\n      animations = Dijkstra(grid, columns, startNode, finishNode);\r\n    if (algorithm === \"best-first\")\r\n      animations = BestFirstSearch(grid, columns, startNode, finishNode);\r\n    if (algorithm === \"depth-first\")\r\n      animations = DepthFirstSearch(grid, columns, startNode, finishNode);\r\n    if (algorithm === \"breadth-first\")\r\n      animations = BreadthFirstSearch(grid, columns, startNode, finishNode);\r\n    const ne = document.getElementsByClassName(\r\n      \"node\"\r\n    ) as HTMLCollectionOf<HTMLElement>;\r\n    for (let i = 0; i < animations.length; i++) {\r\n      ne[animations[i].index].className += animations[i].className + \"Instant\";\r\n    }\r\n  };\r\n\r\n  const [grid, setGrid] = useState(() => GetBlankGrid(0));\r\n  const [startNode, setStartNode] = useState(\r\n    rows * columns - 1 - Math.floor(columns / 2)\r\n  );\r\n  const [finishNode, setFinishNode] = useState(Math.floor(columns / 2));\r\n  const [nodeDimensions, setNodeDimensions] = useState(50);\r\n  const prevFinish = useRef({ index: finishNode, wasWall: false });\r\n  const dispatch = useDispatch();\r\n\r\n  const mouseStatus = useRef(false);\r\n  const startMoveStatus = useRef(false);\r\n  const finishMoveStatus = useRef(false);\r\n  const mouseIndex = useRef(-1);\r\n  const hasSolution = useRef(false);\r\n  const algorithm = useSelector((state: RootStore) => state.algoSelect);\r\n  const solving = useSelector((state: RootStore) => state.startSearch);\r\n  const tiltState = useSelector((state: RootStore) => state.tiltState);\r\n  const speed = useSelector((state: RootStore) => state.searchSpeed);\r\n  const boardChange = useSelector((state: RootStore) => state.boardChange);\r\n\r\n  useEffect(() => {\r\n    if (tiltState) {\r\n      setNodeDimensions(50);\r\n      setStartNode(rows * columns - 1 - Math.floor(columns / 2));\r\n      setFinishNode(Math.floor(columns / 2));\r\n    } else {\r\n      const nodeWidth = (window.innerWidth - 200) / columns;\r\n      setNodeDimensions(nodeWidth);\r\n    }\r\n  }, [tiltState]);\r\n\r\n  useEffect(() => {\r\n    if (solving) StartSearch();\r\n  }, [solving]);\r\n\r\n  useEffect(() => {\r\n    if (hasSolution.current) {\r\n      CleanGrid();\r\n      StartSearchInstant();\r\n    }\r\n  }, [startNode, finishNode]);\r\n\r\n  useEffect(() => {\r\n    if (boardChange.clearBoard) {\r\n      CleanGrid();\r\n      HideHiddenWalls(0);\r\n    } else if (boardChange.clearPath) {\r\n      CleanGrid();\r\n      hasSolution.current = false;\r\n    } else if (boardChange.randomWalls) {\r\n      CleanGrid();\r\n      HideHiddenWalls(30);\r\n    }\r\n  }, [boardChange]);\r\n\r\n  return (\r\n    <div className=\"grid-container\">\r\n      <div\r\n        className=\"grid\"\r\n        style={{\r\n          marginTop: `${tiltState ? \"-314px\" : \"0px\"}`,\r\n          transform: `${tiltState ? \"perspective(800px) rotateX(60deg)\" : \"\"}`,\r\n          gridTemplateColumns: `repeat(${columns},auto)`,\r\n        }}\r\n      >\r\n        {grid.map((_, idx) => {\r\n          return (\r\n            <div\r\n              className={[\r\n                \"node\",\r\n                `${idx === startNode ? \"start\" : \"\"}`,\r\n                `${idx === finishNode ? \"finish\" : \"\"}`,\r\n                `${grid[idx] ? \"wall\" : \"\"}`,\r\n              ].join(\" \")}\r\n              key={idx}\r\n              onMouseDown={() => HandleMouseDown(idx)}\r\n              onMouseEnter={() => HandleMouseEnter(idx)}\r\n              style={{\r\n                width: `${nodeDimensions}px`,\r\n                height: `${nodeDimensions}px`,\r\n              }}\r\n            ></div>\r\n          );\r\n        })}\r\n      </div>\r\n    </div>\r\n  );\r\n};\r\nexport default Grid;\r\n","import React from 'react';\r\nimport './App.css';\r\nimport Header from './components/header/header';\r\nimport Grid from './components/grid/grid';\r\n\r\nfunction App() {\r\n\r\n  return (\r\n    <div className=\"App\">\r\n      <Header/>\r\n      <Grid/>\r\n    </div>\r\n  );\r\n}\r\n\r\nexport default App;","import { boardCommandDispatchTypes } from './boardChangeAction'\r\n\r\ninterface IDefaultState{\r\n    clearBoard: boolean,\r\n    clearPath: boolean,\r\n    randomWalls: boolean\r\n}\r\n\r\nconst initState:IDefaultState = {\r\n    clearBoard: false,\r\n    clearPath: false,\r\n    randomWalls: false\r\n}\r\n\r\nexport const boardChangeReducer = (state:IDefaultState = initState, action: boardCommandDispatchTypes ): IDefaultState => {\r\n    switch(action.type){\r\n        case 'CLEAR_BOARD':\r\n            return {\r\n                clearBoard: true,\r\n                clearPath: false,\r\n                randomWalls: false\r\n            }\r\n        case 'CLEAR_PATH':\r\n            return {\r\n                clearBoard: false,\r\n                clearPath: true,\r\n                randomWalls: false\r\n            }\r\n        case 'RANDOM_WALLS':\r\n            return {\r\n                clearBoard: false,\r\n                clearPath: false,\r\n                randomWalls: true\r\n            }\r\n        default:\r\n            return state\r\n    }\r\n}\r\n","import { createStore, combineReducers } from 'redux'\r\nimport { algoSelectReducer } from './Reducers/algoSelect/algoSelectReducer'\r\nimport { startSearchReducer } from './Reducers/startSearch/startSearchReducer'\r\nimport { tiltStateReducer } from './Reducers/gridTilt/gridTiltReducer'\r\nimport { searchSpeedReducer } from './Reducers/searchSpeed/searchSpeedReducer'\r\nimport { boardChangeReducer } from './Reducers/boardChange/boardChangeReducer'\r\n \r\nconst rootReducer = combineReducers({\r\n    algoSelect: algoSelectReducer,\r\n    startSearch: startSearchReducer,\r\n    tiltState: tiltStateReducer,\r\n    searchSpeed: searchSpeedReducer,\r\n    boardChange: boardChangeReducer\r\n    })\r\n\r\nexport type RootStore = ReturnType<typeof rootReducer>\r\n\r\nexport const store = createStore(rootReducer)","import { algoSelectAction } from './algoSelectActions'\r\n\r\nconst initialState = 'astar'\r\n\r\nexport const algoSelectReducer = (state:string = initialState, action:algoSelectAction) => {\r\n    switch(action.type){\r\n        case \"CHANGE_ALGORITHM\":{\r\n            return action.payload\r\n        }\r\n        default: \r\n            return state\r\n    }\r\n}","import { startSearchAction } from './startSearchActions'\r\n\r\nconst initialState = false\r\n\r\nexport const startSearchReducer = (state:boolean = initialState, action:startSearchAction) => {\r\n    switch(action.type){\r\n        case \"START_SEARCH\" :{\r\n            return action.payload\r\n        }\r\n        default: \r\n            return state\r\n    }\r\n}","import { gridTiltAction } from './gridTiltActions'\r\n\r\nconst initialState = true\r\n\r\nexport const tiltStateReducer = (state:boolean = initialState, action:gridTiltAction) => {\r\n    switch(action.type){\r\n        case 'CHANGE_TILT_STATE' :{\r\n            return action.payload\r\n        }\r\n        default: \r\n            return state\r\n    }\r\n}","import { searchSpeedAction } from './searchSpeedActions'\r\n\r\nconst initState = 10\r\n\r\nexport const searchSpeedReducer = (state:number = initState, action:searchSpeedAction) => {\r\n    switch(action.type){\r\n        case \"CHANGE_SPEED\":\r\n            return action.payload\r\n        default:\r\n            return state\r\n    }\r\n}","import React from 'react';\r\nimport ReactDOM from 'react-dom';\r\nimport App from './App';\r\nimport { Provider } from 'react-redux'\r\nimport { store } from './store'\r\n \r\nReactDOM.render(\r\n  <Provider store={store}>\r\n    <App />\r\n  </Provider>,\r\n  document.getElementById('root')\r\n);\r\n"],"sourceRoot":""}